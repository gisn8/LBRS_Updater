# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LBRS_Updater
                                 A QGIS plugin
 Update address and road LBRS features
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-10-14
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Nathan Saylor
        email                : gisn8@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import math

from PyQt5.QtWidgets import QTableWidgetItem, QComboBox
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
# Initialize Qt resources from file resources.py
from qgis._core import QgsProject, QgsSpatialIndex, QgsFeature, QgsFeatureRequest, QgsGeometry, QgsPoint, QgsPointXY, \
    QgsGeometryUtils, QgsCoordinateReferenceSystem, QgsCoordinateTransform
from qgis.gui import QgsMapToolEmitPoint
from qgis.core import QgsMapLayerProxyModel


from .resources import *

# Import the code for the DockWidget
from .lbrs_updater_dockwidget import LBRS_UpdaterDockWidget
import os.path
import time


class LBRS_Updater:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = self.iface.mapCanvas()

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'LBRS_Updater_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&LBRS Updater')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'LBRS_Updater')
        self.toolbar.setObjectName(u'LBRS_Updater')

        #print "** INITIALIZING LBRS_Updater"

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('LBRS_Updater', message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True,
                   status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/lbrs_updater/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'LBRS Updater'),
            callback=self.run,
            parent=self.iface.mainWindow())

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING LBRS_Updater"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD LBRS_Updater"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&LBRS Updater'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    # --------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING LBRS_Updater"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = LBRS_UpdaterDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.initialize()
            self.dockwidget.show()



    # Tools
    def get_layer(self, layer_name):
        try:
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            return layer
        except:
            try:
                layer = QgsProject.instance().mapGroupLayersByName(layer_name)[0]
                return layer
            except:
                pass

    def check_for_fields(self, layer, fields):
        # modified from https://gis.stackexchange.com/questions/299263/
        i = 1
        for field in fields:
            field_index = layer.fields().indexFromName(field)
            if field_index == -1:
                i = i * 0
            else:
                i = i * 1
        j = 1
        for field in fields:
            field_index = layer.fields().indexFromName(field.upper())
            if field_index == -1:
                j = j * 0
            else:
                j = j * 1
        if (i == 1) or (j == 1):
            return 1

    def get_feature_values_list(self, layer, field_name, filter_=None, distinct=1):
        # Used to populate values in combo boxes
        if filter_ is None:
            filter_ = f'{field_name} is not NULL'
        else:
            pass

        features = layer.getFeatures(filter_)
        list_ = []
        for feature in features:
            list_.append(feature[field_name])

        if distinct == 1:
            distinct_list = self.make_list_distinct(list_)
            return distinct_list
        else:
            return list_

    def make_list_distinct(self, list_):
        distinct_list = []
        for item in list(set(list_)):
            distinct_list.append(item)
        distinct_list.sort()
        return distinct_list

    def pop_tbl(self, layer, table, filter_=None, show_fields_list=[]):
        # layer = self.get_layer(layer_name)
        self.reset_result_displays()

        if filter_ is None:
            filter_ = '1=1'
        features = layer.getFeatures(filter_)

        table.setColumnCount(layer.fields().count())

        row = 0
        for feature in features:
            table.insertRow(row)
            for col in range(layer.fields().count()):
                table.setItem(row, col, QTableWidgetItem(str(feature[col])))
                # print(r"row: %s, col: %s, %s" % (row, col, feature[col]))
            row += 1

        # Probably will be argued in later as the rest of this already is.
        self.dockwidget.lbl_SearchAddress_Results.setText(f'Results: {row}')
        # That or just sneak it in because no one is looking anyway and it's demand is negligible

        if row == 0:
            self.reset_result_displays()
        else:
            field_names = []
            for field in layer.fields():
                # print(field.name())
                # field_names.append(u'%s' % field.name())
                field_names.append(f"{field.name()}")
            table.setHorizontalHeaderLabels(field_names)

            if len(show_fields_list) > 0:
                for field_name in field_names:
                    if field_name not in show_fields_list:
                        table.setColumnHidden(layer.fields().indexFromName(field_name), True)

        table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)

    def get_selected_row_cell(self, table, field_name):
        row = table.currentItem().row()
        if row is None:
            pass
        else:
            row = table.currentItem().row()
            # print(row)
            # col = table.currentItem().column()

            # loop through headers and find column number for given column name
            header_count = table.columnCount()
            for x in range(0, header_count, 1):
                header_name = table.horizontalHeaderItem(x).text()
                if field_name == header_name:
                    cell = table.item(row, x).text()  # get cell at row, col
                    # print(cell)ll
                    return cell

    def zoom_to_feature(self, layer):
        # Get selected item from result table, query for duplicates. If duplicates found, pop up box with cboBox to
        # select from to continue, then zoom to features.

        query = f"gid = {self.get_selected_row_cell(self.dockwidget.tbl_SearchAddress_Results, 'gid')}"
        # print(query)

        # Hold any selected features to give back after the function
        held_ids = [f.id() for f in layer.selectedFeatures()]
        layer.removeSelection()

        features = layer.getFeatures(query)
        ids = [i.id() for i in features]
        # print(len(ids))
        layer.selectByIds(ids)
        self.canvas.zoomToSelected(layer)
        self.canvas.flashFeatureIds(ids)

        # clear zooming selection and re-select original selected features
        layer.removeSelection()
        layer.selectByIds(held_ids)

        # Will also shake the canvas into not showing the zoomed feature as selected if it wasn't to begin with.
        # if scale != None:
        self.canvas.zoomScale(600)

    def get_xy_from_canvas(self, point, button):
        # Report map coordinates from a canvas click
        canvas_ppoint = self.create_ppoint(point=point, crs=QgsProject.instance().crs())
        self.canvas_spoint = self.convert_ppoint(canvas_ppoint, to_crs_id=4326)

        # print(f"{x}, {y}")

    def solve_angle(self, from_ppoint, to_ppoint):
        # From https://qgis.org/pyqgis/3.2/core/Geometry/QgsGeometryUtils.html#qgis.core.QgsGeometryUtils.lineAngle
        # Used for ABSSIDE value determination. DO NOT DELETE!
        # .lineAngle results in radians and need converted with math.degrees.
        # Angles are calculated clockwise from North.
        # By default, labels are perpendicular to the angle, so correct with a-90 for our purposes.
        # Note: Pad labels with 3 spaces on either side to get proper distance from point.
        # We'll want to integrate this into a newly formatted address layer when we're ready.
        a = QgsGeometryUtils.lineAngle(from_ppoint["x"], from_ppoint["y"],  to_ppoint["x"], to_ppoint["y"])

        angle = round(math.degrees(a), 3)

        return angle

    def get_crs_id_from_layer(self, layer):
        crs_id = int(layer.crs().authid().replace('EPSG:', ''))
        return crs_id

    def create_ppoint(self, point=None, x=None, y=None, crs=None, crs_id=None):
        # ppoints are a means to keep the point and it's projection together; previous iterations were getting hard to 
        # keep track of.

        if (point is None) and (x is not None) and (y is not None):
            point = QgsPointXY(x, y)
        if (point is not None) and ((x is None) or (y is None)):
            x = point.x()
            y = point.y()

        if (crs is None) and (crs_id is not None):
            crs = QgsCoordinateReferenceSystem(crs_id)
        if (crs is not None) and (crs_id is None):
            crs_id = int(crs.authid().replace('EPSG:', ''))

        ppoint = {"point": point, "x": x, "y": y, "crs": crs, "crs_id": crs_id}

        return ppoint

    def convert_ppoint(self, ppoint, to_crs_id=None):
        # Convert a given PointXY object and get location assignments for DD and map projection units
        # Derived from https://youtu.be/3YXjYAdAyjo

        point, x, y, from_crs, from_crs_id = ppoint["point"], ppoint["x"], ppoint["y"], ppoint["crs"], ppoint["crs_id"]

        print(f"INTAKE: point:{point}, x:{x}, y:{y}, from_crs_id:{from_crs_id}, to_crs_id:{to_crs_id}")

        if to_crs_id is None:
            # default is address layer crs
            to_crs = self.address_layer.crs()
            to_crs_id = int(to_crs.authid().replace('EPSG:', ''))
        else:
            to_crs = QgsCoordinateReferenceSystem(to_crs_id)

        # Convert to to_crs
        to_crs_transformation = QgsCoordinateTransform(from_crs, to_crs, QgsProject.instance())
        new_point = to_crs_transformation.transform(QgsPointXY(x, y))
        new_x = new_point.x()
        new_y = new_point.y()

        output = {"point": new_point, "x": new_x, "y": new_y, "crs": to_crs, "crs_id": to_crs_id}

        print(f"OUTPUTS: {output}")
        return output



    # Dockwidget
    def initialize(self):
        # Form prep
        self.set_connections()
        self.reset_layer_cbos()
        self.reset_form()
        self.limit_layer_cbo_types()
        self.set_layers()

        self.dockwidget.lblError.setText('Be sure edit sessions are closed on impacted layers.')

        # For dev
        self.dockwidget.stackedWidget.setCurrentIndex(2)

    def set_layers(self, submitted=0):
        if submitted == 0:
            self.address_layer = self.get_layer('addresses') or None
            self.road_layer = self.get_layer('roads') or None
        else:
            self.address_layer = self.dockwidget.mLyrCbo_Addresses.currentLayer()
            self.road_layer = self.dockwidget.mLyrCbo_Roads.currentLayer()

        if (self.address_layer is None) or (self.road_layer is None):
            self.dockwidget.lblError.setText('Missing valid address and road layers')

    def set_connections(self):
        # All
        self.dockwidget.btnReset.clicked.connect(lambda: self.reset_form())

        # Page 0 - Menu
        self.set_menu_connections()

        # Page 1 - Search for Address
        self.set_search_address_connections()

        # Page 2 - Add Address
        self.set_add_address_connections()

    def reset_form(self):
        # -- Variables --
        self.canvas_spoint = None

        # -- Dockwidget --

        # Set default warning message to empty
        self.dockwidget.lblError.setText('')

        # Return to Menu
        self.dockwidget.stackedWidget.setCurrentIndex(0)

        # -- Menu --
        self.reset_menu_form()

        # -- Address Search --
        self.reset_address_search_form()

        # -- Add Address --
        self.reset_add_address_form()


    # Menu page
    def set_menu_connections(self):
        self.dockwidget.mLyrCbo_Addresses.currentTextChanged.connect(lambda: self.validate_selected_layers())
        self.dockwidget.mLyrCbo_Roads.currentTextChanged.connect(lambda: self.validate_selected_layers())
        self.dockwidget.btn_Menu_Continue.clicked.connect(lambda: self.continue_from_menu())

    def reset_layer_cbos(self):
        # Commenting out for development. Reinstate when ready.
        self.dockwidget.mLyrCbo_Addresses.setCurrentIndex(-1)
        self.dockwidget.mLyrCbo_Roads.setCurrentIndex(-1)
        self.dockwidget.grpTools.setEnabled(False)

    def limit_layer_cbo_types(self):
        # From https://github.com/qgis/QGIS/issues/38472
        # The map layer combo boxes don't translate layer type filters even after resetting them manually.
        # This is the workaround. Requires: from qgis.core import QgsMapLayerProxyModel
        self.dockwidget.mLyrCbo_Addresses.setFilters(QgsMapLayerProxyModel.PointLayer)
        self.dockwidget.mLyrCbo_Roads.setFilters(QgsMapLayerProxyModel.LineLayer)

    def reset_menu_form(self):
        self.dockwidget.cbo_Menu_Tool.setCurrentIndex(0)
        self.dockwidget.cbo_Menu_FeatureType.setCurrentIndex(0)

    def validate_selected_layers(self):
        a, r = 0, 0

        address_field_checklist = ['featureid', 'housenum', 'unitnum', 'comment', 'side', 'absside', 'struc_type',
                                   'source', 'comment', 'x', 'y', 'segid']
        road_field_checklist = ['segid', 'roadtype', 'roadnumber', 'st_prefix', 'st_name', 'st_type', 'st_suffix',
                           'altprefix', 'altname', 'alttype', 'altsuffix', 'fieldnote', 'leftfrom', 'rightto']

        if ((self.dockwidget.mLyrCbo_Addresses.currentIndex() != -1) and
                (self.dockwidget.mLyrCbo_Roads.currentIndex() != -1)):
            a = self.check_for_fields(self.dockwidget.mLyrCbo_Addresses.currentLayer(), address_field_checklist)
            if a == 1:
                layer = self.dockwidget.mLyrCbo_Addresses.currentLayer()

                if layer.isEditable():
                    # True/False if the dialog should offer Cancel or not. Here, we do not want edit sessions to be mixed.
                    self.iface.vectorLayerTools().stopEditing(layer, False)

                r = self.check_for_fields(self.dockwidget.mLyrCbo_Roads.currentLayer(), road_field_checklist)

                if r == 1:
                    layer = self.dockwidget.mLyrCbo_Roads.currentLayer()
                    if layer.isEditable():
                        self.iface.vectorLayerTools().stopEditing(layer, False)
                    # Have to turn off/on the lbl in order for the message to appear while processing the layers
                    self.dockwidget.lblError.setVisible(False)
                    self.dockwidget.lblError.setText('Loading data...')
                    self.dockwidget.lblError.setVisible(True)
                    self.dockwidget.repaint()
                    self.load_initial_data()
                    self.dockwidget.lblError.setText('')
                    self.dockwidget.grpTools.setEnabled(True)
                    
                else:
                    self.dockwidget.grpTools.setEnabled(False)
                    self.dockwidget.lblError.setText('Road layer invalid')
            else:
                self.dockwidget.grpTools.setEnabled(False)
                self.dockwidget.lblError.setText('Address layer invalid')
                
        self.set_layers(submitted=a*r)

    def load_initial_data(self):
        # Search for Address
        self.dockwidget.cbo_SearchAddress_st_name.addItem('')
        self.dockwidget.cbo_SearchAddress_comm.addItem('')

        self.dockwidget.cbo_SearchAddress_st_prefix.addItems(
            self.get_feature_values_list(self.address_layer, field_name='st_prefix'))
        self.dockwidget.cbo_SearchAddress_st_name.addItems(
            self.get_feature_values_list(self.address_layer, field_name='st_name'))
        self.dockwidget.cbo_SearchAddress_st_type.addItems(
            self.get_feature_values_list(self.address_layer, field_name='st_type'))
        self.dockwidget.cbo_SearchAddress_st_suffix.addItems(
            self.get_feature_values_list(self.address_layer, field_name='st_suffix'))
        self.dockwidget.cbo_SearchAddress_comm.addItems(
            self.get_feature_values_list(self.address_layer, field_name='comm'))

        self.dockwidget.cbo_SearchAddress_lsn.addItem('')
        self.dockwidget.cbo_SearchAddress_lsn.addItems(
            self.get_feature_values_list(self.address_layer, field_name='lsn'))

        self.dockwidget.list_SearchAddress_roads_lsn.addItems(
            self.get_feature_values_list(self.road_layer, field_name='lsn'))

        # Add Address
        if self.address_layer.crs() is not None:
            self.dockwidget.rad_AddAddressByPoint_LayerCRS.setText(f"Address Layer CRS [{self.address_layer.crs().authid()}]")
        else:
            self.dockwidget.rad_AddAddressByPoint_LayerCRS.setText("Address Later CRS")

    def continue_from_menu(self):
        if self.dockwidget.cbo_Menu_FeatureType.currentText() == 'Address':
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Search for':
                self.dockwidget.stackedWidget.setCurrentIndex(1)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Add':
                self.dockwidget.stackedWidget.setCurrentIndex(2)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Update':
                self.dockwidget.stackedWidget.setCurrentIndex(3)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Re-Align':
                self.dockwidget.stackedWidget.setCurrentIndex(4)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Retire':
                self.dockwidget.stackedWidget.setCurrentIndex(5)

        else:
            # For quick access in dev
            self.dockwidget.stackedWidget.setCurrentIndex(2)


    # Search Address page
    def set_search_address_connections(self):
        # Tab change
        self.dockwidget.tabs_SearchAddress.currentChanged.connect(lambda: self.reset_result_displays())
        # Find
        self.dockwidget.btn_SearchAddress_Find.clicked.connect(lambda: self.execute_address_query())
        # Clear
        self.dockwidget.btn_SearchAddress_Clear.clicked.connect(lambda: self.reset_address_search_form())
        # Zoom
        self.dockwidget.btn_SearchAddress_Zoom.clicked.connect(
            lambda: self.zoom_to_feature(self.address_layer))
        # Continue
        self.dockwidget.btn_SearchAddress_Continue.clicked.connect(lambda: self.continue_from_address_search())

    def reset_address_search_form(self):
        self.dockwidget.lblError.setText('')

        self.dockwidget.ln_SearchAddress_housenum.clear()
        self.dockwidget.ln_SearchAddress_unitnum.clear()
        self.dockwidget.cbo_SearchAddress_st_prefix.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_name.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_type.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_suffix.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_comm.setCurrentIndex(0)

        self.dockwidget.cbo_SearchAddress_lsn.setCurrentIndex(0)
        
        self.reset_result_displays()

        self.dockwidget.cbo_SearchAddress_Tool.setCurrentIndex(0)

    def reset_result_displays(self): 
        self.dockwidget.tbl_SearchAddress_Results.clear()
        self.dockwidget.tbl_SearchAddress_Results.setColumnCount(0)
        self.dockwidget.tbl_SearchAddress_Results.setRowCount(0)
        self.dockwidget.lbl_SearchAddress_Results.setText('Results: 0')
        self.dockwidget.lblError.setText('')

    def execute_address_query(self):
        # get active address tab, build search parameters based on the active tab, and populate results
        self.dockwidget.lblError.setText('')
        query = ''
        address_tab_index = self.dockwidget.tabs_SearchAddress.currentIndex()

        # Component Search
        if address_tab_index == 0:
            query = '1=1'

            if len(self.dockwidget.ln_SearchAddress_housenum.text()) > 0:
                query = f"{query} AND to_string(housenum) = '{self.dockwidget.ln_SearchAddress_housenum.text()}'"

            if len(self.dockwidget.ln_SearchAddress_unitnum.text()) > 0:
                query = f"{query} AND unitnum = '{self.dockwidget.ln_SearchAddress_unitnum.text()}'"

            if len(self.dockwidget.cbo_SearchAddress_st_prefix.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_prefix = '{self.dockwidget.cbo_SearchAddress_st_prefix.currentText()}' OR " \
                        f"altprefix = '{self.dockwidget.cbo_SearchAddress_st_prefix.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_name.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_name = '{self.dockwidget.cbo_SearchAddress_st_name.currentText()}' OR " \
                        f"altname = '{self.dockwidget.cbo_SearchAddress_st_name.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_type.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_type = '{self.dockwidget.cbo_SearchAddress_st_type.currentText()}' OR " \
                        f"alttype = '{self.dockwidget.cbo_SearchAddress_st_type.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_suffix.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_suffix = '{self.dockwidget.cbo_SearchAddress_st_suffix.currentText()}' OR " \
                        f"altsuffix = '{self.dockwidget.cbo_SearchAddress_st_suffix.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_comm.currentText()) > 0:
                query = f"{query} AND comm = '{self.dockwidget.cbo_SearchAddress_comm.currentText()}'"

            if query == '1=1':
                query = ''

        # Free-form Search
        if address_tab_index == 1:
            query = f"%{self.dockwidget.cbo_SearchAddress_lsn.currentText()}%"
            if query == '%%':
                query = ''
            else:
                query = f"lsn LIKE '{query}' OR alsn LIKE '{query}'"

        # Street-Level Search
        if address_tab_index == 2:
            if self.dockwidget.list_SearchAddress_roads_lsn.currentItem() is not None:
                query = f"% {self.dockwidget.list_SearchAddress_roads_lsn.currentItem().text()}"
                if query == '% ':
                    query = ''
                else:
                    query = f"lsn LIKE '{query}' OR alsn LIKE '{query}'"

        self.dockwidget.tbl_SearchAddress_Results.hide()
        self.dockwidget.repaint()
        time.sleep(0.02)
        self.dockwidget.tbl_SearchAddress_Results.show()
        self.dockwidget.repaint()

        if query != '':
            # print(query)
            self.pop_tbl(self.address_layer, self.dockwidget.tbl_SearchAddress_Results,
                                    filter_=f'{query}', show_fields_list=['comment', 'lsn', 'comm', 'datemodifi'])
        else:
            self.reset_result_displays()
            self.dockwidget.lblError.setText('Error: Please refine search')

    def continue_from_address_search(self):
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Add':
            self.dockwidget.stackedWidget.setCurrentIndex(2)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Update':
            self.dockwidget.stackedWidget.setCurrentIndex(3)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Re-Align':
            self.dockwidget.stackedWidget.setCurrentIndex(4)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Retire':
            self.dockwidget.stackedWidget.setCurrentIndex(5)


    # Add Address page -- Add By Point
    def Add_Address_checklist():

        #Add Address page
        # Add Address by Point checklist
        """
        -- Steps to add address by point. --
        [X] layer validation (done beforehand)
        [X] click the button
        [X] get the previous tool
        [X] switch to xy tool
        [X] Cancel xy tool
        [X] override selected road tool
        [X] convert PointXY values to DD and layer.prj units
        [X] set coordinate labels
        [X] seek nearest road segment feature
        [X] activate address and road tables
        [X] use road data to fill in address data table
        [X] calculate housenum and absside
        [X] Add cboBox to table cell? For struc_type
        [X] begin edit of address layer
        [X] add feature to address layer
        [X] Function and connect Clear button on AddAddress form
        [ ] Function and connect Commit button on AddAddress form
        [ ] Make flexible for upper, lower, and mixed case field names
        [ ] By Distance form
        [ ]

        Considerations
        Do we want to utilize ROW and snap to? Would require pointing to another reference layer... No.
        Set in-town and out-of-town distances from road CL to snap address points to? No. Not unless we're overriding
        for apartment entrances.
        Assign address to specific building AND link to aud_outbuilding... Should attempt an automated method to link
        together probably 75% of them, then tediously going through the other 25%.
        """
        pass

    def set_add_address_connections(self):
        self.dockwidget.btn_AddAddressByPoint_PlacePointOnMap.clicked.connect(lambda: self.start_xy_tool('PlacePointOnMap'))
        self.dockwidget.btn_AddAddressbyPoint_OverrideSelectedRoad.clicked.connect(lambda: self.start_xy_tool('OverrideSelectedRoad'))
        self.dockwidget.btn_AddAddressByPoint_EnterManually.clicked.connect(lambda: self.dockwidget.stackedWidget_2.setCurrentIndex(1))
        self.dockwidget.btn_AddAddressByPoint_Cancel.clicked.connect(self.cancel_canvas_capture)

        # Manual Entry page buttons
        self.dockwidget.btn_AddAddressbyPoint_GoBack.clicked.connect(lambda: self.dockwidget.stackedWidget_2.setCurrentIndex(0))
        self.dockwidget.btn_AddAddressByPoint_AcceptManualInput.clicked.connect(self.manual_point_entry)

        self.dockwidget.btn_AddAddressByPoint_Clear.clicked.connect(self.reset_add_address_form)
        self.dockwidget.btn_AddAddressByPoint_Commit.clicked.connect(self.commit_feature_to_layer)

    def reset_add_address_form(self):
        # Reset tables
        row_count = self.dockwidget.tbl_AddAddress_AddressInfo.rowCount()
        for row in range(row_count):
            item = QTableWidgetItem(str(row * 0))
            item.setText('')
            self.dockwidget.tbl_AddAddress_AddressInfo.setItem(row, 0, item)

        row_count = self.dockwidget.tbl_AddAddress_RoadInfo.rowCount()
        for row in range(row_count):
            item = QTableWidgetItem(str(row * 0))
            item.setText('')
            self.dockwidget.tbl_AddAddress_RoadInfo.setItem(row, 0, item)

        self.cbo_struc_type = QtWidgets.QComboBox()

        self.struc_values = {
            1: "House",
            2: "Duplex",
            3: "Trailer",
            4: "Apartment (single unit)",
            5: "Secondary (barn, garage, etc. with address)",
            6: "Utility (gas, electric, cellular, etc.)",
            7: "Commercial",
            8: "Address with no visible structure",
            9: "Apartment (one entrance w/suffix range)",
            10: "Campground Lot",
            11: "Landmark (cemetery, park, etc.)",
            12: "Apartment (one entrance w/address range)",
            # 13 not used
            14: "Points for Review"
        }

        for key in self.struc_values:
            self.cbo_struc_type.addItem(f"{key} - {self.struc_values[key]}")

        self.cbo_struc_type.setCurrentIndex(-1)
        table = self.dockwidget.tbl_AddAddress_AddressInfo
        row_count = table.rowCount()
        for row in range(row_count):
            row_name = table.verticalHeaderItem(row).text()
            if row_name == 'struc_type':
                table.setCellWidget(row, 0, self.cbo_struc_type)

        # De-activate tables
        self.dockwidget.tbl_AddAddress_AddressInfo.setEnabled(False)
        self.dockwidget.tbl_AddAddress_RoadInfo.setEnabled(False)

        # Reset coord labels
        self.dockwidget.lbl_AddAddress_Lat.setText('')
        self.dockwidget.lbl_AddAddress_Long.setText('')
        self.dockwidget.lbl_AddAddress_X.setText('')
        self.dockwidget.lbl_AddAddress_Y.setText('')

        # De-activate buttons
        self.dockwidget.btn_AddAddressbyPoint_OverrideSelectedRoad.setEnabled(False)
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(False)
        self.dockwidget.btn_AddAddressByPoint_Clear.setEnabled(False)
        self.dockwidget.btn_AddAddressByPoint_Commit.setEnabled(False)

    def start_xy_tool(self, btn):
        # User clicks a button to launch capture point from canvas for either the address point or select the necessary 
        # road. Once the point is captured, we use the button they launched with to determine what comes next.

        layer = self.address_layer
        if layer.isEditable():
            layer.rollBack()

        # Create the map tool using the canvas reference
        # A self. assignment was found necessary for the tool to work ¯\_(ツ)_/¯. Pycharm doesn't like creating
        #   a self.variable outside __init__, but it works just fine!
        self.xy_tool = QgsMapToolEmitPoint(self.canvas)
        self.xy_tool.canvasClicked.connect(self.get_xy_from_canvas)  # The connect works just fine; shut up, PyCharm.
        if btn == 'PlacePointOnMap':
            self.xy_tool.canvasClicked.connect(self.manage_address_coords)
        if btn == 'OverrideSelectedRoad':
            self.xy_tool.canvasClicked.connect(self.solve_attributes)

        self.canvas.setMapTool(self.xy_tool)
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(True)

    def cancel_canvas_capture(self):
        self.iface.mapCanvas().unsetMapTool(self.xy_tool)
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(False)

    def manual_point_entry(self):
        # Create spoint using manually entered values from form then pass on.
        address_spoint = None
        if self.dockwidget.rad_AddAddressByPoint_DD.isChecked():
            address_spoint = self.create_ppoint(x=self.dockwidget.dblsp_AddAddressByPoint_Long.value(),
                                                y=self.dockwidget.dblsp_AddAddressByPoint_Lat.value(), crs_id=4326)

        elif self.dockwidget.rad_AddAddressByPoint_LayerCRS.isChecked():
            ppoint = self.create_ppoint(x=self.dockwidget.dblsp_AddAddressByPoint_X.value(),
                                        y=self.dockwidget.dblsp_AddAddressByPoint_Y.value(),
                                        crs_id=self.get_crs_id_from_layer(self.address_layer))
            address_spoint = self.convert_ppoint(ppoint=ppoint, to_crs_id=4326)

        self.manage_address_coords(clicked_point=None, mouse_button=None, address_spoint=address_spoint)

        self.dockwidget.stackedWidget_2.setCurrentIndex(0)

    def manage_address_coords(self, clicked_point, mouse_button, address_spoint=None):  # The clicked_point and mouse_button come from the xy_tool are forced to come along for the ride.
        # Either by canvas capture or manual entry, by now, we should now have an spoint ("standard (4326) point").

        if address_spoint is None:
            address_spoint = self.canvas_spoint

        address_ppoint = self.convert_ppoint(ppoint=address_spoint,
                                             to_crs_id=self.get_crs_id_from_layer(self.address_layer))

        layer_x = address_ppoint['x']
        layer_y = address_ppoint['y']
        lat = address_spoint['y']
        long = address_spoint['x']

        self.dockwidget.lbl_AddAddress_X.setText(f"{round(layer_x, 3)}")
        self.dockwidget.lbl_AddAddress_Y.setText(f"{round(layer_y, 3)}")
        self.dockwidget.lbl_AddAddress_Lat.setText(f"{round(lat,7)}")
        self.dockwidget.lbl_AddAddress_Long.setText(f"{round(long,7)}")

        self.dockwidget.btn_AddAddressbyPoint_OverrideSelectedRoad.setEnabled(True)
        self.dockwidget.btn_AddAddressByPoint_Clear.setEnabled(True)
        self.dockwidget.btn_AddAddressByPoint_Commit.setEnabled(True)

        # self.solve_attributes(point, point_crs_id)
        self.solve_attributes(clicked_point, mouse_button, spoint=address_spoint)

    def solve_attributes(self, clicked_point, mouse_button, spoint=None):  # The clicked_point and mouse_button come from the xy_tool are forced to come along for the ride.
        # Get the spoint (could be from address placement, could be from override) and get the desired road segment data
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(False)

        self.dockwidget.tbl_AddAddress_AddressInfo.setEnabled(True)
        self.dockwidget.tbl_AddAddress_RoadInfo.setEnabled(True)

        # print("solve_attributes")
        if spoint is None:
            spoint = self.canvas_spoint

        road_feature_data = self.get_nearest_road_feature(ppoint=spoint)

        self.road_feature = road_feature_data['road_feature']
        road_feature = self.road_feature
        context = road_feature_data['context']

        m_dist = context['m_dist']
        side_t = context['side_of_line']

        length = road_feature.geometry().length()

        # road projected point
        road_ppoint = self.create_ppoint(point=context['nearest_point_on_line'],
                                         crs_id=self.get_crs_id_from_layer(self.road_layer))
        # address projected road point
        road_appoint = self.convert_ppoint(ppoint=road_ppoint, to_crs_id=self.get_crs_id_from_layer(self.address_layer))
        # address projected address point
        appoint = self.convert_ppoint(ppoint=spoint, to_crs_id=self.get_crs_id_from_layer(self.address_layer))

        # print(f"""Point 1: {road_appoint}
        # Point 2: {appoint}""")
        angle = self.solve_angle(from_ppoint=road_appoint, to_ppoint=appoint)

        # Label angle now handled in database, but snippet still useful.
        # label_angle = round(angle - 90, 3)
        # print(f"angle: {angle}")
        # print(f"label_angle: {label_angle}")

        if (angle > 45) and (angle <=135):
            absside = 'E'
        elif (angle > 135) and (angle <= 225):
            absside = 'S'
        elif (angle > 225) and (angle <=315):
            absside = 'W'
        else:
            absside = 'N'

        if side_t == 'l':
            side_text = 'left'
            side = 0
        else:
            side_text = 'right'
            side = 1

        l_lsn = self.build_lsn(st_prefix=road_feature['lprefix'] or '',
                               st_name=road_feature['lname'] or '',
                               st_type=road_feature['ltype'] or '',
                               st_suffix=road_feature['lsuffix'] or '')
        r_lsn = self.build_lsn(st_prefix=road_feature['rprefix'] or '',
                               st_name=road_feature['rname'] or '',
                               st_type=road_feature['rtype'] or '',
                               st_suffix=road_feature['rsuffix'] or '')

        road_values = {
            "segid": str(int(road_feature['segid'])),
            "roadtype": road_feature['roadtype'],
            "roadnumber": road_feature['roadnumber'],
            "leftfrom": road_feature['leftfrom'],
            "leftto": road_feature['leftto'],
            "l_lsn": l_lsn,
            "lcomm": road_feature['lcomm'],
            "rightfrom": road_feature['rightfrom'],
            "rightto": road_feature['rightto'],
            "r_lsn": r_lsn,
            "rcomm": road_feature['rcomm'],
            "length": round(length, 3)
        }
        enabled_road_cells = []
        self.pop_feature_input_values_table(self.dockwidget.tbl_AddAddress_RoadInfo, road_values, enabled_road_cells)

        housenum = self.solve_housenum(from_=road_feature[f"{side_text}from"], to_=road_feature[f"{side_text}to"],
                                       m_dist=m_dist, length=length)

        st_lsn = self.build_lsn(st_prefix=road_feature[f"{side_t}prefix"] or road_feature['st_prefix'] or '',
                                st_name=road_feature[f"{side_t}name"] or road_feature['st_name'] or '',
                                st_type=road_feature[f"{side_t}type"] or road_feature['st_type'] or '',
                                st_suffix=road_feature[f"{side_t}suffix"] or road_feature['st_suffix'] or '')

        address_values = {
            "segid": str(int(road_feature['segid'])),
            "housenum": housenum,
            "unitnum": '',
            "struc_type": '',
            "poi_name": '',
            "st_lsn": st_lsn,
            "absside": absside,
            "muni": road_feature[f"{side_t}addmuni"] or '',
            "zipcode": road_feature[f"{side_text}zip"],
            "comm": road_feature[f"{side_t}comm"],
            "note": '',
            "side": side,
            "x": str(float(self.dockwidget.lbl_AddAddress_X.text())),
            "y": str(float(self.dockwidget.lbl_AddAddress_Y.text()))
        }
        enabled_address_cells = ['housenum', 'unitnum', 'struc_type', 'poi_name', 'note']
        self.pop_feature_input_values_table(self.dockwidget.tbl_AddAddress_AddressInfo, address_values, enabled_address_cells)

        # Even though it seems redundant to do this here and in self.commit_feature_to_layer, there are significant
        # manipulations that need to happen before the final commit is actually made. Additionally, trying it here as is
        # would add two points on top of one another unnoticeably.
        layer = self.address_layer
        layer.startEditing()
        feat = QgsFeature(layer.fields())
        for key in address_values:
            # print(f"{key}: {address_values[key]}")
            try:
                feat.setAttribute(layer.fields().indexFromName(key), address_values[key])
            except KeyError:
                pass
        for key in road_values:
            # print(f"{key}: {road_values[key]}")
            try:
                feat.setAttribute(layer.fields().indexFromName(key), road_values[key])
            except KeyError:
                pass

        feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(round(float(self.dockwidget.lbl_AddAddress_X.text()), 3),
                                                            round(float(self.dockwidget.lbl_AddAddress_Y.text()), 3))))
        layer.addFeature(feat)
        self.canvas.refreshAllLayers()
        self.canvas.refresh()


        self.cbo_struc_type.setCurrentIndex(-1)

        self.canvas.unsetMapTool(self.xy_tool)

    def get_nearest_road_feature(self, ppoint):
        # From https://gis.stackexchange.com/questions/59173/finding-nearest-line-to-point-in-qgis
        features = self.road_layer.getFeatures()

        point = self.convert_ppoint(ppoint=ppoint, to_crs_id=self.get_crs_id_from_layer(self.road_layer))['point']

        spatial_index = QgsSpatialIndex()  # create spatial index object

        # insert features to index
        for feature in features:
            spatial_index.insertFeature(feature)

        # QgsSpatialIndex.nearestNeighbor (QgsPoint point, int neighbors)
        fids = spatial_index.nearestNeighbor(point, 5)  # Comparing nearest 5. Using only 1 was not always accurate.
        dist = 999999
        fid_hold = 0
        context_hold = None
        for fid in fids:
            road_features = self.road_layer.getFeatures(f"$id = {fid}")
            for road_feature in road_features:
                context = self.get_nearest_road_segment_context(road_feature, point)
                min_dist = context['min_dist']
                if min_dist < dist:
                    dist = min_dist
                    fid_hold = fid
                    context_hold = context

        road_features = self.road_layer.getFeatures(f"$id = {fid_hold}")
        road_feature = None  # Just to shut up PyCharm
        # No, feats[0] does not work.
        for road_feature in road_features:
            break
        return {'road_feature': road_feature, 'context': context_hold, 'reprojected_point': point}

    def get_nearest_road_segment_context(self, road_feature, point):
        # From https://qgis.org/api/classQgsGeometry.html#af949da066f8d1649a043cd320af1e7f7
        segment_context = road_feature.geometry().closestSegmentWithContext(point)
        # print(segment_context)  # prints the list of values and objects

        # The output is the distance squared. num ** (1/2) finds the square root.
        min_dist = segment_context[0] ** (1 / 2)

        # Is a geometry object; should be able to work out the m_distance with this.
        nearest_point_on_line = segment_context[1]

        # It can figure out the closest point to the line without needing it exactly on the line.
        # point_geom = QgsGeometry.fromPointXY(point)
        # m_dist = road_feature.geometry().lineLocatePoint(point_geom)

        # But since we've already got it calculated, why waste processing time on it again?
        m_dist = road_feature.geometry().lineLocatePoint(QgsGeometry.fromPointXY(segment_context[1]))

        # Technically, it's the next vertex index, but easier to think of it this way.
        nearest_segment_of_line = segment_context[2]

        # -1 = Left, 0 = On the line, 1 = Right;
        # figure this will keep anything from breaking down if it's accidentally on the line.
        if segment_context[3] <= 0:
            side_of_line = 'l'
        elif segment_context[3] == 1:
            side_of_line = 'r'

        """
        print(f"min_dist: {min_dist}")
        print(f"nearest_point_on_line: {nearest_point_on_line}")
        print(f"m_dist: {m_dist}")
        print(f"nearest_segment_of_line: {nearest_segment_of_line}")
        print(f"side_of_line: {side_of_line}")
        """

        # Then x = get_nearest_road_segment_context('variable_name')
        return {'min_dist': min_dist, 'nearest_point_on_line': nearest_point_on_line, 'm_dist': m_dist,
                'nearest_segment_of_line': nearest_segment_of_line, 'side_of_line': side_of_line}

    def solve_housenum(self, from_=0, to_=0, m_dist=0, length=0):
        pct = m_dist / length

        if to_ - from_ >= 0:
            numsign = 1
        else:
            numsign = -1

        min_ = min(from_, to_)
        max_ = max(from_, to_)
        range_ = max_ - min_
        val_ = range_ * pct
        floor_ = math.floor(from_ + (val_ * numsign))
        ceil_ = math.ceil(from_ + (val_ * numsign))

        if (from_ % 2) != (to_ % 2):
            housenum = round(min_ + val_)
        elif (from_ % 2) == (floor_ % 2):
            housenum = floor_
        else:
            housenum = ceil_

        return housenum

    def build_lsn(self, housenum='', unitnum='', st_prefix='', st_name='', st_type='', st_suffix=''):
        lsn = ''

        if not st_name:
            return st_name

        if housenum and (housenum != ''):
            lsn = f"{housenum} "
        if unitnum and (unitnum != ''):
            lsn = f"{lsn}{unitnum} "
        if st_prefix and (st_prefix != ''):
            lsn = f"{lsn}{st_prefix} "

        lsn = f"{lsn}{st_name}"

        if st_type and (st_type != ''):
            lsn = f"{lsn} {st_type}"
        if st_suffix and (st_suffix != ''):
            lsn = f"{lsn} {st_suffix}"

        return lsn

    def pop_feature_input_values_table(self, table, values, enabled_cells):
        row_count = table.rowCount()
        for row in range(row_count):
            row_name = table.verticalHeaderItem(row).text()
            item = QTableWidgetItem(str(row * 0))
            if row_name in enabled_cells:
                flags = (Qt.ItemIsEditable | Qt.ItemIsEnabled)
            else:
                flags = Qt.ItemIsEnabled
            item.setFlags(flags)
            item.setText(f"{values[row_name]}")
            table.setItem(row, 0, item)

    def commit_feature_to_layer(self):
        # Grab the updated values and create the new point.
        # Because the initial and final values will be different and a feature edit will have to go line by line of the
        # dialog anyway, might as well rollback and re-enter the point with the given values.

        layer = self.address_layer
        field_names = [field.name() for field in layer.fields()]
        committing_values = {}
        for field in field_names:
            # print(field)
            try:
                committing_values[field] = self.road_feature[field]
            except:
                pass

        table = self.dockwidget.tbl_AddAddress_AddressInfo
        row_count = table.rowCount()
        for row in range(row_count):
            row_name = table.verticalHeaderItem(row).text()
            widget = table.cellWidget(row, 0)
            item = table.item(row, 0)
            if isinstance(widget, QComboBox):
                current_value = widget.currentText()
            else:
                current_value = item.text()
            print(f"{row_name}: {current_value}")
            committing_values[row_name] = current_value

        # Need to calculate lsn and struc_type AFTER (b/c of lsn) we get remaining values from matching segid road.
        if len(committing_values['struc_type']) == 0:
            self.dockwidget.lblError.setText('Please set a struc_type value!')
            return
        else:
            self.dockwidget.lblError.setText('')
            self.dockwidget.repaint()

        committing_values['lsn'] = self.build_lsn(
            housenum=committing_values["housenum"],
            unitnum=committing_values["unitnum"],
            st_name=self.road_feature["lsn"]
        )

        committing_values['alsn'] = self.build_lsn(
            housenum=committing_values["housenum"],
            unitnum=committing_values["unitnum"],
            st_name=self.road_feature["alsn"]
        )

        for key in self.struc_values:
            if committing_values["struc_type"] == f"{key} - {self.struc_values[key]}":
                committing_values["struc_type"] = key


        if layer.isEditable():
            layer.rollBack()
        layer.startEditing()
        feat = QgsFeature(layer.fields())
        for key in committing_values:
            print(f"committing {key}: {committing_values[key]}")
            try:
                feat.setAttribute(layer.fields().indexFromName(key), committing_values[key])
            except KeyError:
                pass

        feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(round(float(self.dockwidget.lbl_AddAddress_X.text()), 3),
                                                            round(float(self.dockwidget.lbl_AddAddress_Y.text()), 3))))
        layer.addFeature(feat)
        self.canvas.refreshAllLayers()
        self.canvas.refresh()
        # This is just a stopgap in the case that Commit was accidentally clicked on.
        # It pops up the Save/Discard dialog.
        if layer.isEditable():
            # True/False if the dialog should offer Cancel or not. This can give us the opportunity to modify values
            # without having to start all over. Assigning a variable can show whether the dialog was carried out (Saved
            # or Discarded)(True) or canceled (so continue editing)(False).
            stopped_editing = self.iface.vectorLayerTools().stopEditing(layer, True)
            if stopped_editing == True:
                self.reset_add_address_form()


    #   Add Address page -- Add By Distance
    #   Add Address page -- Add By Calculation

