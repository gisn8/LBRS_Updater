# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LBRS_Updater
                                 A QGIS plugin
 Update address and road LBRS features
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-10-14
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Nathan Saylor
        email                : gisn8@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtWidgets import QTableWidgetItem
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
# Initialize Qt resources from file resources.py
from qgis._core import QgsProject
from qgis.gui import QgsMapToolEmitPoint

from .resources import *

# Import the code for the DockWidget
from .lbrs_updater_dockwidget import LBRS_UpdaterDockWidget
import os.path
import time


class LBRS_Updater:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'LBRS_Updater_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&LBRS Updater')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'LBRS_Updater')
        self.toolbar.setObjectName(u'LBRS_Updater')

        #print "** INITIALIZING LBRS_Updater"

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('LBRS_Updater', message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True,
                   status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/lbrs_updater/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'LBRS Updater'),
            callback=self.run,
            parent=self.iface.mainWindow())

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING LBRS_Updater"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD LBRS_Updater"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&LBRS Updater'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    # --------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING LBRS_Updater"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = LBRS_UpdaterDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

        self.set_connections()
        self.load_initial_data()
        self.reset_form()

    def set_connections(self):
        # All
        self.dockwidget.btnReset.clicked.connect(lambda: self.reset_form())

        # Page 0 - Menu
        self.dockwidget.btn_Menu_Continue.clicked.connect(lambda: self.continue_from_menu())

        # Page 1 - Search for Address
        # Tab change
        self.dockwidget.tab_SearchAddress.currentChanged.connect(lambda: self.reset_result_displays())
        # Find
        self.dockwidget.btn_SearchAddress_Find.clicked.connect(lambda: self.execute_address_query())
        # Clear
        self.dockwidget.btn_SearchAddress_Clear.clicked.connect(lambda: self.reset_address_search_form())
        # Zoom
        self.dockwidget.btn_SearchAddress_Zoom.clicked.connect(
            lambda: self.zoom_to_feature(self.get_layer('addresses')))
        # Continue
        self.dockwidget.btn_SearchAddress_Continue.clicked.connect(lambda: self.continue_from_address_search())

    def load_initial_data(self):
        self.dockwidget.cbo_SearchAddress_st_name.addItem('')
        self.dockwidget.cbo_SearchAddress_comm.addItem('')

        address_layer = self.get_layer('addresses')
        roads_layer = self.get_layer('roads')

        self.dockwidget.cbo_SearchAddress_st_prefix.addItems(
            self.get_feature_values_list(address_layer, field_name='st_prefix'))
        self.dockwidget.cbo_SearchAddress_st_name.addItems(
            self.get_feature_values_list(address_layer, field_name='st_name'))
        self.dockwidget.cbo_SearchAddress_st_type.addItems(
            self.get_feature_values_list(address_layer, field_name='st_type'))
        self.dockwidget.cbo_SearchAddress_st_suffix.addItems(
            self.get_feature_values_list(address_layer, field_name='st_suffix'))
        self.dockwidget.cbo_SearchAddress_comm.addItems(
            self.get_feature_values_list(address_layer, field_name='comm'))

        self.dockwidget.cbo_SearchAddress_lsn.addItem('')
        self.dockwidget.cbo_SearchAddress_lsn.addItems(
            self.get_feature_values_list(address_layer, field_name='lsn'))

        self.dockwidget.list_SearchAddress_roads_lsn.addItems(
            self.get_feature_values_list(roads_layer, field_name='lsn'))

    def reset_form(self):
        # Menu
        # Address Search
        self.reset_address_search_form()

        # Set default and hide error warning
        self.dockwidget.lblError.setText('')

        # Return to Menu
        self.dockwidget.stackedWidget.setCurrentIndex(0)

    def reset_address_search_form(self):
        self.dockwidget.lblError.setText('')

        self.dockwidget.ln_SearchAddress_housenum.clear()
        self.dockwidget.ln_SearchAddress_unitnum.clear()
        self.dockwidget.cbo_SearchAddress_st_prefix.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_name.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_type.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_suffix.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_comm.setCurrentIndex(0)

        self.dockwidget.cbo_SearchAddress_lsn.setCurrentIndex(0)
        
        self.reset_result_displays()

        self.dockwidget.cbo_SearchAddress_Tool.setCurrentIndex(0)

    def reset_result_displays(self): 
        self.dockwidget.tbl_SearchAddress_Results.clear()
        self.dockwidget.tbl_SearchAddress_Results.setColumnCount(0)
        self.dockwidget.tbl_SearchAddress_Results.setRowCount(0)
        self.dockwidget.lbl_SearchAddress_Results.setText('Results: 0')
        self.dockwidget.lblError.setText('')
    
    def continue_from_menu(self):
        self.dockwidget.stackedWidget.setCurrentIndex(1)

    def execute_address_query(self):
        # get active address tab, build search parameters based on the active tab, and populate results
        self.dockwidget.lblError.setText('')
        query = ''
        address_tab_index = self.dockwidget.tab_SearchAddress.currentIndex()

        # Component Search
        if address_tab_index == 0:
            query = '1=1'

            if len(self.dockwidget.ln_SearchAddress_housenum.text()) > 0:
                query = f"{query} AND to_string(housenum) = '{self.dockwidget.ln_SearchAddress_housenum.text()}'"

            if len(self.dockwidget.ln_SearchAddress_unitnum.text()) > 0:
                query = f"{query} AND unitnum = '{self.dockwidget.ln_SearchAddress_unitnum.text()}'"

            if len(self.dockwidget.cbo_SearchAddress_st_prefix.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_prefix = '{self.dockwidget.cbo_SearchAddress_st_prefix.currentText()}' OR " \
                        f"altprefix = '{self.dockwidget.cbo_SearchAddress_st_prefix.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_name.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_name = '{self.dockwidget.cbo_SearchAddress_st_name.currentText()}' OR " \
                        f"altname = '{self.dockwidget.cbo_SearchAddress_st_name.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_type.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_type = '{self.dockwidget.cbo_SearchAddress_st_type.currentText()}' OR " \
                        f"alttype = '{self.dockwidget.cbo_SearchAddress_st_type.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_suffix.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_suffix = '{self.dockwidget.cbo_SearchAddress_st_suffix.currentText()}' OR " \
                        f"altsuffix = '{self.dockwidget.cbo_SearchAddress_st_suffix.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_comm.currentText()) > 0:
                query = f"{query} AND comm = '{self.dockwidget.cbo_SearchAddress_comm.currentText()}'"

            if query == '1=1':
                query = ''

        # Free-form Search
        if address_tab_index == 1:
            query = f"%{self.dockwidget.cbo_SearchAddress_lsn.currentText()}%"
            if query == '%%':
                query = ''
            else:
                query = f"lsn LIKE '{query}' OR alsn LIKE '{query}'"

        # Street-Level Search
        if address_tab_index == 2:
            if self.dockwidget.list_SearchAddress_roads_lsn.currentItem() is not None:
                query = f"% {self.dockwidget.list_SearchAddress_roads_lsn.currentItem().text()}"
                if query == '% ':
                    query = ''
                else:
                    query = f"lsn LIKE '{query}' OR alsn LIKE '{query}'"

        self.dockwidget.tbl_SearchAddress_Results.hide()
        self.dockwidget.repaint()
        time.sleep(0.02)
        self.dockwidget.tbl_SearchAddress_Results.show()
        self.dockwidget.repaint()

        if query != '':
            # print(query)
            self.pop_tbl(self.get_layer('addresses'), self.dockwidget.tbl_SearchAddress_Results,
                                    filter_=f'{query}', show_fields_list=['comment', 'lsn', 'comm', 'datemodifi'])
        else:
            self.reset_result_displays()
            self.dockwidget.lblError.setText('Error: Please refine search')

    def get_layer(self, layer_name):
        try:
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            return layer
        except:
            try:
                layer = QgsProject.instance().mapGroupLayersByName(layer_name)[0]
                return layer
            except:
                pass

    def get_feature_values_list(self, layer, field_name, filter_=None, distinct=1):
        if filter_ is None:
            filter_ = f'{field_name} is not NULL'
        else:
            pass

        features = layer.getFeatures(filter_)
        list_ = []
        for feature in features:
            list_.append(feature[field_name])

        if distinct == 1:
            distinct_list = self.make_list_distinct(list_)
            return distinct_list
        else:
            return list_

    def make_list_distinct(self, list_):
        distinct_list = []
        for item in list(set(list_)):
            distinct_list.append(item)
        distinct_list.sort()
        return distinct_list

    def pop_tbl(self, layer, table, filter_=None, show_fields_list=[]):
        # layer = self.get_layer(layer_name)
        self.reset_result_displays()

        if filter_ is None:
            filter_ = 'lsn is not null'
        features = layer.getFeatures(filter_)

        table.setColumnCount(layer.fields().count())

        row = 0
        for feature in features:
            table.insertRow(row)
            for col in range(layer.fields().count()):
                table.setItem(row, col, QTableWidgetItem(str(feature[col])))
                # print(r"row: %s, col: %s, %s" % (row, col, feature[col]))
            row += 1

        # Probably will be argued in later as the rest of this already is.
        self.dockwidget.lbl_SearchAddress_Results.setText(f'Results: {row}')
        # That or just sneak it in because no one is looking anyway and it's demand is negligible

        if row == 0:
            self.reset_result_displays()
        else:
            field_names = []
            for field in layer.fields():
                # print(field.name())
                # field_names.append(u'%s' % field.name())
                field_names.append(f"{field.name()}")
            table.setHorizontalHeaderLabels(field_names)

            if len(show_fields_list) > 0:
                for field_name in field_names:
                    if field_name not in show_fields_list:
                        table.setColumnHidden(layer.fields().indexFromName(field_name), True)

        # table.setHorizontalHeader.setSectionResizeMode(ResizeToContents) # Doesn't work
        # table.setHorizontalHeader.sectionSizeFromContents() # Doesn't work either

    def get_selected_row_cell(self, table, field_name):
        row = table.currentItem().row()
        if row is None:
            pass
        else:
            row = table.currentItem().row()
            # print(row)
            # col = table.currentItem().column()

            # loop through headers and find column number for given column name
            header_count = table.columnCount()
            for x in range(0, header_count, 1):
                header_name = table.horizontalHeaderItem(x).text()
                if field_name == header_name:
                    cell = table.item(row, x).text()  # get cell at row, col
                    # print(cell)ll
                    return cell

    def zoom_to_feature(self, layer):
        # Get selected item from result table, query for duplicates. If duplicates found, pop up box with cboBox to
        # select from to continue, then zoom to features.

        query = f"gid = {self.get_selected_row_cell(self.dockwidget.tbl_SearchAddress_Results, 'gid')}"
        # print(query)
        canvas = self.iface.mapCanvas()

        # Hold any selected features to give back after the function
        held_ids = [f.id() for f in layer.selectedFeatures()]
        layer.removeSelection()

        features = layer.getFeatures(query)
        ids = [i.id() for i in features]
        # print(len(ids))
        layer.selectByIds(ids)
        canvas.zoomToSelected(layer)

        # clear zooming selection and re-select original selected features
        layer.removeSelection()
        layer.selectByIds(held_ids)

        # Will also shake the canvas into not showing the zoomed feature as selected if it wasn't to begin with.
        # if scale != None:
        canvas.zoomScale(600)

    def continue_from_address_search(self):
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Add':
            self.dockwidget.stackedWidget.setCurrentIndex(2)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Update':
            self.dockwidget.stackedWidget.setCurrentIndex(3)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Re-Align':
            self.dockwidget.stackedWidget.setCurrentIndex(4)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Retire':
            self.dockwidget.stackedWidget.setCurrentIndex(5)

    def get_previous_tool(self):
        prev_tool = self.iface.mapCanvas().mapTool()
        self.iface.mapCanvas().setMapTool(yadayada)

    def get_xy_from_canvas(self, point, button):
        xy = "{}, {}".format(point.x(), point.y())
        return xy

    def add_address_point(self):
        # WIP!!! Some of this is pseudocode
        layer = self.get_layer('addresses')

        layer.startEditing()

        feat = QgsFeature(layer.fields())

        # Need some mechanism to capture XY here
        canvas = self.iface.mapCanvas()
        point_tool = QgsMapToolEmitPoint(self.iface.mapCanvas())
        # geometry coordinates given need to be in (or converted to) the layer's CRS
        feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(123, 456)))

        # Need to find nearest road segment to pull attributes into the form to confirm or override.

        # The data will be confirmed via the form and entered here. Do we want hidden fields or values kept in variable?
        feat.setAttributes([('housenum', self.dockwidget.ln_AddAddress_housenum), ('lsn', rfeature['lsn'])])  # idk
        # Or set a single attribute by key or by index:
        # feat.setAttribute('name', 'hello')
        # feat.setAttribute(0, 'hello')

        layer.addFeatures([feat])
        self.iface.mapCanvas().refresh()

        # To save edits: layer.commitChanges()
        # To rollback and turn off edits: layer.rollback()
        # If you want to stay in edit mode, you'll need to re-initialize: layer.startEditing()
