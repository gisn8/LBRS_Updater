# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LBRS_Updater
                                 A QGIS plugin
 Update address and road LBRS features
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-10-14
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Nathan Saylor
        email                : gisn8@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtWidgets import QTableWidgetItem
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
# Initialize Qt resources from file resources.py
from qgis._core import QgsProject, QgsSpatialIndex, QgsFeature, QgsFeatureRequest, QgsGeometry, QgsPoint, QgsPointXY
from qgis.gui import QgsMapToolEmitPoint
from qgis.core import QgsMapLayerProxyModel


from .resources import *

# Import the code for the DockWidget
from .lbrs_updater_dockwidget import LBRS_UpdaterDockWidget
import os.path
import time


class LBRS_Updater:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = self.iface.mapCanvas()

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'LBRS_Updater_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&LBRS Updater')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'LBRS_Updater')
        self.toolbar.setObjectName(u'LBRS_Updater')

        #print "** INITIALIZING LBRS_Updater"

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('LBRS_Updater', message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True,
                   status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/lbrs_updater/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'LBRS Updater'),
            callback=self.run,
            parent=self.iface.mainWindow())

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING LBRS_Updater"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD LBRS_Updater"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&LBRS Updater'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    # --------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING LBRS_Updater"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = LBRS_UpdaterDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.initialize()
            self.dockwidget.show()




    # Tools
    def get_layer(self, layer_name):
        try:
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            return layer
        except:
            try:
                layer = QgsProject.instance().mapGroupLayersByName(layer_name)[0]
                return layer
            except:
                pass

    def check_for_fields(self, layer, fields):
        # modified from https://gis.stackexchange.com/questions/299263/
        i = 1
        for field in fields:
            field_index = layer.fields().indexFromName(field)
            if field_index == -1:
                i = i * 0
            else:
                i = i * 1
        return i

    def get_feature_values_list(self, layer, field_name, filter_=None, distinct=1):
        # Used to populate values in combo boxes
        if filter_ is None:
            filter_ = f'{field_name} is not NULL'
        else:
            pass

        features = layer.getFeatures(filter_)
        list_ = []
        for feature in features:
            list_.append(feature[field_name])

        if distinct == 1:
            distinct_list = self.make_list_distinct(list_)
            return distinct_list
        else:
            return list_

    def make_list_distinct(self, list_):
        distinct_list = []
        for item in list(set(list_)):
            distinct_list.append(item)
        distinct_list.sort()
        return distinct_list

    def pop_tbl(self, layer, table, filter_=None, show_fields_list=[]):
        # layer = self.get_layer(layer_name)
        self.reset_result_displays()

        if filter_ is None:
            filter_ = 'lsn is not null'
        features = layer.getFeatures(filter_)

        table.setColumnCount(layer.fields().count())

        row = 0
        for feature in features:
            table.insertRow(row)
            for col in range(layer.fields().count()):
                table.setItem(row, col, QTableWidgetItem(str(feature[col])))
                # print(r"row: %s, col: %s, %s" % (row, col, feature[col]))
            row += 1

        # Probably will be argued in later as the rest of this already is.
        self.dockwidget.lbl_SearchAddress_Results.setText(f'Results: {row}')
        # That or just sneak it in because no one is looking anyway and it's demand is negligible

        if row == 0:
            self.reset_result_displays()
        else:
            field_names = []
            for field in layer.fields():
                # print(field.name())
                # field_names.append(u'%s' % field.name())
                field_names.append(f"{field.name()}")
            table.setHorizontalHeaderLabels(field_names)

            if len(show_fields_list) > 0:
                for field_name in field_names:
                    if field_name not in show_fields_list:
                        table.setColumnHidden(layer.fields().indexFromName(field_name), True)

        # table.setHorizontalHeader.setSectionResizeMode(ResizeToContents) # Doesn't work
        # table.setHorizontalHeader.sectionSizeFromContents() # Doesn't work either

    def get_selected_row_cell(self, table, field_name):
        row = table.currentItem().row()
        if row is None:
            pass
        else:
            row = table.currentItem().row()
            # print(row)
            # col = table.currentItem().column()

            # loop through headers and find column number for given column name
            header_count = table.columnCount()
            for x in range(0, header_count, 1):
                header_name = table.horizontalHeaderItem(x).text()
                if field_name == header_name:
                    cell = table.item(row, x).text()  # get cell at row, col
                    # print(cell)ll
                    return cell

    def zoom_to_feature(self, layer):
        # Get selected item from result table, query for duplicates. If duplicates found, pop up box with cboBox to
        # select from to continue, then zoom to features.

        query = f"gid = {self.get_selected_row_cell(self.dockwidget.tbl_SearchAddress_Results, 'gid')}"
        # print(query)
        canvas = self.iface.mapCanvas()

        # Hold any selected features to give back after the function
        held_ids = [f.id() for f in layer.selectedFeatures()]
        layer.removeSelection()

        features = layer.getFeatures(query)
        ids = [i.id() for i in features]
        # print(len(ids))
        layer.selectByIds(ids)
        canvas.zoomToSelected(layer)

        # clear zooming selection and re-select original selected features
        layer.removeSelection()
        layer.selectByIds(held_ids)

        # Will also shake the canvas into not showing the zoomed feature as selected if it wasn't to begin with.
        # if scale != None:
        canvas.zoomScale(600)

    def get_xy_from_canvas(self, point, button):
        # Report map coordinates from a canvas click
        self.x = point.x()
        self.y = point.y()
        self.point = point
        # print(f"{x}, {y}")




    # Dockwidget
    def initialize(self):
        self.set_connections()
        self.reset_layer_cbos()
        self.reset_form()
        self.limit_layer_cbo_types()

        # For dev
        self.dockwidget.stackedWidget.setCurrentIndex(2)

    def set_connections(self):
        # All
        self.dockwidget.btnReset.clicked.connect(lambda: self.reset_form())

        # Page 0 - Menu
        self.set_menu_connections()

        # Page 1 - Search for Address
        self.set_search_address_connections()

        # Page 2 - Add Address
        self.set_add_address_connections()


    def reset_form(self):
        # -- Variables --
        self.point = None

        # -- Dockwidget --

        # Set default and hide error warning
        self.dockwidget.lblError.setText('')

        # Return to Menu
        self.dockwidget.stackedWidget.setCurrentIndex(0)

        # -- Menu --
        self.reset_menu_form()

        # -- Address Search --
        self.reset_address_search_form()

        # -- Add Address --
        self.reset_add_address_form()




    # Menu page
    def set_menu_connections(self):
        self.dockwidget.mLyrCbo_Addresses.currentTextChanged.connect(lambda: self.activate_menu_tools())
        self.dockwidget.mLyrCbo_Roads.currentTextChanged.connect(lambda: self.activate_menu_tools())
        self.dockwidget.btn_Menu_Continue.clicked.connect(lambda: self.continue_from_menu())

    def reset_layer_cbos(self):
        # Commenting out for development. Reinstate when ready.
        self.dockwidget.mLyrCbo_Addresses.setCurrentIndex(-1)
        self.dockwidget.mLyrCbo_Roads.setCurrentIndex(-1)
        self.dockwidget.grpTools.setEnabled(False)

    def limit_layer_cbo_types(self):
        # From https://github.com/qgis/QGIS/issues/38472
        # The map layer combo boxes don't translate layer type filters even after resetting them manually.
        # This is the workaround. Requires: from qgis.core import QgsMapLayerProxyModel
        self.dockwidget.mLyrCbo_Addresses.setFilters(QgsMapLayerProxyModel.PointLayer)
        self.dockwidget.mLyrCbo_Roads.setFilters(QgsMapLayerProxyModel.LineLayer)

    def reset_menu_form(self):
        self.dockwidget.cbo_Menu_Tool.setCurrentIndex(0)
        self.dockwidget.cbo_Menu_FeatureType.setCurrentIndex(0)

    def activate_menu_tools(self):
        if ((self.dockwidget.mLyrCbo_Addresses.currentIndex() != -1) and (self.dockwidget.mLyrCbo_Roads.currentIndex() != -1)):
            a = self.check_for_fields(self.dockwidget.mLyrCbo_Addresses.currentLayer(),['featureid', 'housenum',
                                                                                        'unitnum', 'comment', 'side',
                                                                                        'absside', 'struc_type',
                                                                                        'source', 'comment', 'x' , 'y'])
            if a == 1:
                r = self.check_for_fields(self.dockwidget.mLyrCbo_Roads.currentLayer(), ['segid', 'roadtype', 'roadnumber',
                                                                                         'st_prefix', 'st_name', 'st_type', 'st_suffix',
                                                                                         'altprefix', 'altname', 'alttype', 'altsuffix',
                                                                                         'fieldnote', 'leftfrom', 'rightto'])
                if r == 1:
                    self.dockwidget.lblError.setVisible(False)
                    self.dockwidget.lblError.setText('Loading data...')
                    self.dockwidget.lblError.setVisible(True)
                    self.dockwidget.repaint()
                    self.load_initial_data()
                    self.dockwidget.lblError.setText('')
                    self.dockwidget.grpTools.setEnabled(True)
                else:
                    self.dockwidget.grpTools.setEnabled(False)
                    self.dockwidget.lblError.setText('Road layer invalid')
            else:
                self.dockwidget.grpTools.setEnabled(False)
                self.dockwidget.lblError.setText('Address layer invalid')

    def load_initial_data(self):
        self.dockwidget.cbo_SearchAddress_st_name.addItem('')
        self.dockwidget.cbo_SearchAddress_comm.addItem('')

        address_layer = self.dockwidget.mLyrCbo_Addresses.currentLayer()
        roads_layer = self.dockwidget.mLyrCbo_Roads.currentLayer()

        self.dockwidget.cbo_SearchAddress_st_prefix.addItems(
            self.get_feature_values_list(address_layer, field_name='st_prefix'))
        self.dockwidget.cbo_SearchAddress_st_name.addItems(
            self.get_feature_values_list(address_layer, field_name='st_name'))
        self.dockwidget.cbo_SearchAddress_st_type.addItems(
            self.get_feature_values_list(address_layer, field_name='st_type'))
        self.dockwidget.cbo_SearchAddress_st_suffix.addItems(
            self.get_feature_values_list(address_layer, field_name='st_suffix'))
        self.dockwidget.cbo_SearchAddress_comm.addItems(
            self.get_feature_values_list(address_layer, field_name='comm'))

        self.dockwidget.cbo_SearchAddress_lsn.addItem('')
        self.dockwidget.cbo_SearchAddress_lsn.addItems(
            self.get_feature_values_list(address_layer, field_name='lsn'))

        self.dockwidget.list_SearchAddress_roads_lsn.addItems(
            self.get_feature_values_list(roads_layer, field_name='lsn'))

    def continue_from_menu(self):
        if self.dockwidget.cbo_Menu_FeatureType.currentText() == 'Address':
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Search for':
                self.dockwidget.stackedWidget.setCurrentIndex(1)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Add':
                self.dockwidget.stackedWidget.setCurrentIndex(2)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Update':
                self.dockwidget.stackedWidget.setCurrentIndex(3)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Re-Align':
                self.dockwidget.stackedWidget.setCurrentIndex(4)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Retire':
                self.dockwidget.stackedWidget.setCurrentIndex(5)

        else:
            # For quick access in dev
            self.dockwidget.stackedWidget.setCurrentIndex(2)


    # Search Address page
    def set_search_address_connections(self):
        # Tab change
        self.dockwidget.tabs_SearchAddress.currentChanged.connect(lambda: self.reset_result_displays())
        # Find
        self.dockwidget.btn_SearchAddress_Find.clicked.connect(lambda: self.execute_address_query())
        # Clear
        self.dockwidget.btn_SearchAddress_Clear.clicked.connect(lambda: self.reset_address_search_form())
        # Zoom
        self.dockwidget.btn_SearchAddress_Zoom.clicked.connect(
            lambda: self.zoom_to_feature(self.dockwidget.mLyrCbo_Addresses.currentLayer()))
        # Continue
        self.dockwidget.btn_SearchAddress_Continue.clicked.connect(lambda: self.continue_from_address_search())

    def reset_address_search_form(self):
        self.dockwidget.lblError.setText('')

        self.dockwidget.ln_SearchAddress_housenum.clear()
        self.dockwidget.ln_SearchAddress_unitnum.clear()
        self.dockwidget.cbo_SearchAddress_st_prefix.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_name.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_type.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_suffix.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_comm.setCurrentIndex(0)

        self.dockwidget.cbo_SearchAddress_lsn.setCurrentIndex(0)
        
        self.reset_result_displays()

        self.dockwidget.cbo_SearchAddress_Tool.setCurrentIndex(0)

    def reset_result_displays(self): 
        self.dockwidget.tbl_SearchAddress_Results.clear()
        self.dockwidget.tbl_SearchAddress_Results.setColumnCount(0)
        self.dockwidget.tbl_SearchAddress_Results.setRowCount(0)
        self.dockwidget.lbl_SearchAddress_Results.setText('Results: 0')
        self.dockwidget.lblError.setText('')

    def execute_address_query(self):
        # get active address tab, build search parameters based on the active tab, and populate results
        self.dockwidget.lblError.setText('')
        query = ''
        address_tab_index = self.dockwidget.tab_SearchAddress.currentIndex()

        # Component Search
        if address_tab_index == 0:
            query = '1=1'

            if len(self.dockwidget.ln_SearchAddress_housenum.text()) > 0:
                query = f"{query} AND to_string(housenum) = '{self.dockwidget.ln_SearchAddress_housenum.text()}'"

            if len(self.dockwidget.ln_SearchAddress_unitnum.text()) > 0:
                query = f"{query} AND unitnum = '{self.dockwidget.ln_SearchAddress_unitnum.text()}'"

            if len(self.dockwidget.cbo_SearchAddress_st_prefix.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_prefix = '{self.dockwidget.cbo_SearchAddress_st_prefix.currentText()}' OR " \
                        f"altprefix = '{self.dockwidget.cbo_SearchAddress_st_prefix.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_name.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_name = '{self.dockwidget.cbo_SearchAddress_st_name.currentText()}' OR " \
                        f"altname = '{self.dockwidget.cbo_SearchAddress_st_name.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_type.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_type = '{self.dockwidget.cbo_SearchAddress_st_type.currentText()}' OR " \
                        f"alttype = '{self.dockwidget.cbo_SearchAddress_st_type.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_suffix.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_suffix = '{self.dockwidget.cbo_SearchAddress_st_suffix.currentText()}' OR " \
                        f"altsuffix = '{self.dockwidget.cbo_SearchAddress_st_suffix.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_comm.currentText()) > 0:
                query = f"{query} AND comm = '{self.dockwidget.cbo_SearchAddress_comm.currentText()}'"

            if query == '1=1':
                query = ''

        # Free-form Search
        if address_tab_index == 1:
            query = f"%{self.dockwidget.cbo_SearchAddress_lsn.currentText()}%"
            if query == '%%':
                query = ''
            else:
                query = f"lsn LIKE '{query}' OR alsn LIKE '{query}'"

        # Street-Level Search
        if address_tab_index == 2:
            if self.dockwidget.list_SearchAddress_roads_lsn.currentItem() is not None:
                query = f"% {self.dockwidget.list_SearchAddress_roads_lsn.currentItem().text()}"
                if query == '% ':
                    query = ''
                else:
                    query = f"lsn LIKE '{query}' OR alsn LIKE '{query}'"

        self.dockwidget.tbl_SearchAddress_Results.hide()
        self.dockwidget.repaint()
        time.sleep(0.02)
        self.dockwidget.tbl_SearchAddress_Results.show()
        self.dockwidget.repaint()

        if query != '':
            # print(query)
            self.pop_tbl(self.dockwidget.mLyrCbo_Addresses, self.dockwidget.tbl_SearchAddress_Results,
                                    filter_=f'{query}', show_fields_list=['comment', 'lsn', 'comm', 'datemodifi'])
        else:
            self.reset_result_displays()
            self.dockwidget.lblError.setText('Error: Please refine search')

    def continue_from_address_search(self):
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Add':
            self.dockwidget.stackedWidget.setCurrentIndex(2)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Update':
            self.dockwidget.stackedWidget.setCurrentIndex(3)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Re-Align':
            self.dockwidget.stackedWidget.setCurrentIndex(4)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Retire':
            self.dockwidget.stackedWidget.setCurrentIndex(5)


    #Add Address page
    def set_add_address_connections(self):
        self.dockwidget.btn_AddAddressByPoint_PlaceAddressPoint.clicked.connect(lambda: self.start_xy_tool('PlaceAddressPoint'))
        self.dockwidget.btn_AddAddressbyPoint_OverrideSelectedRoad.clicked.connect(lambda: self.start_xy_tool('OverrideSelectedRoad'))
        self.dockwidget.btn_AddAddressByPoint_Cancel.clicked.connect(self.cancel_canvas_capture)

    def reset_add_address_form(self):
        # Clear tables
        row_count = self.dockwidget.tbl_AddAddress_AddressInfo.rowCount()
        for row in range(row_count):
            item = QTableWidgetItem(str(row * 0))
            item.setText('')
            self.dockwidget.tbl_AddAddress_RoadInfo.setItem(row, 0, item)

        # De-activate tables


        # Reset coord labels
        self.dockwidget.lbl_AddAddress_Lat.setText('')
        self.dockwidget.lbl_AddAddress_Long.setText('')
        self.dockwidget.lbl_AddAddress_X.setText('')
        self.dockwidget.lbl_AddAddress_Y.setText('')

    # WIP
    """
    -- Steps to add address by point. -- 
    [x] layer validation (done beforehand)
    [x] click the button
    [x] get the previous tool
    [x] switch to xy tool
    [x] Cancel xy tool?
    [ ] override selected road tool
    [ ] convert PointXY values to DD and layer.prj units
    [ ] set coordinate labels
    [ ] seek nearest road segment feature
    [ ] activate address and road tables
    [ ] use road data to fill in address data table
    [ ] calculate housenum and absside
    [ ] begin edit of address layer
    [ ] add feature to address layer
    """

    def start_xy_tool(self, btn):
        # Pycharm doesn't like creating a self.variable outside __init__. Tough! It works just fine!
        # Doing this just in case we have a point already assigned and decided we didn't want to override it.
        if self.point == None:
            self.x = 0
            self.y = 0

        # Get the current tool
        self.prev_tool = self.canvas.mapTool()

        # Create the map tool using the canvas reference
        # A self. assignment was found necessary for the tool to work ¯\_(ツ)_/¯
        self.xy_tool = QgsMapToolEmitPoint(self.canvas)
        self.xy_tool.canvasClicked.connect(self.get_xy_from_canvas)  # The connect works just fine
        if btn == 'PlaceAddressPoint':
            self.xy_tool.canvasClicked.connect(self.manage_address_attributes)
        if btn == 'OverrideSelectedRoad':
            self.xy_tool.canvasClicked.connect(self.get_context_attributes)
        self.canvas.setMapTool(self.xy_tool)
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(True)

    def manage_address_attributes(self):
        self.dockwidget.lbl_AddAddress_X.setText(f"{round(self.x, 3)}")
        self.dockwidget.lbl_AddAddress_Y.setText(f"{round(self.y, 3)}")
        self.dockwidget.btn_AddAddressbyPoint_OverrideSelectedRoad.setEnabled(True)
        self.get_context_attributes()
    
    def build_lsn(self, housenum='', st_prefix='', st_name='', st_type='', st_suffix=''):
        lsn = ''
        if housenum != '':
            lsn = f"{housenum} "
        if st_prefix != '':
            lsn = f"{lsn}{st_prefix} "
        lsn = f"{lsn}{st_name}"
        if st_type != '':
            lsn = f"{lsn} {st_type}"
        if st_suffix != '':
            lsn = f"{lsn} {st_suffix}"

        return lsn

    def get_context_attributes(self):
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(False)

        self.dockwidget.tbl_AddAddress_AddressInfo.setEnabled(True)
        self.dockwidget.tbl_AddAddress_RoadInfo.setEnabled(True)

        road_feature_data = self.get_nearest_road_feature(self.point)
        road_feature = road_feature_data['road_feature']
        context = road_feature_data['context']
        m_dist = context['m_dist']
        side_of_line = context['side_of_line']

        st_lsn = self.build_lsn(housenum='',
                                st_prefix=road_feature[f"{side_of_line}prefix"] or road_feature['st_prefix'] or '',
                                st_name=road_feature[f"{side_of_line}name"] or road_feature['st_name'] or '',
                                st_type=road_feature[f"{side_of_line}type"] or road_feature['st_type'] or '',
                                st_suffix=road_feature[f"{side_of_line}suffix"] or road_feature['st_suffix'] or '')

        address_values = {
            "segid": str(int(road_feature['segid'])),
            "housenum": '',
            "unitnum": '',
            "struc_type": '',
            "poi_name": '',
            "st_lsn": st_lsn,
            "absside": '',
            "muni": '',
            "zipcode": '',
            "comm": '',
            "note": ''
        }
        enabled_address_cells = ['housenum', 'unitnum', 'struc_type', 'poi_name', 'note']
        self.pop_result_values_table(self.dockwidget.tbl_AddAddress_AddressInfo, address_values, enabled_address_cells)

        l_lsn = self.build_lsn(housenum='', 
                               st_prefix=road_feature['lprefix'] or '', 
                               st_name=road_feature['lname'] or '',
                               st_type=road_feature['ltype'] or '', 
                               st_suffix=road_feature['lsuffix'] or '')
        r_lsn = self.build_lsn(housenum='', 
                               st_prefix=road_feature['rprefix'] or '', 
                               st_name=road_feature['rname'] or '',
                               st_type=road_feature['rtype'] or '', 
                               st_suffix=road_feature['rsuffix'] or '')

        road_values = {
            "segid": str(int(road_feature['segid'])),
            "roadtype": road_feature['roadtype'],
            "roadnumber": road_feature['roadnumber'],
            "leftfrom": road_feature['leftfrom'],
            "leftto": road_feature['leftto'],
            "l_lsn": l_lsn,
            "lcomm": road_feature['lcomm'],
            "rightfrom": road_feature['rightfrom'],
            "rightto": road_feature['rightto'],
            "r_lsn": r_lsn,
            "rcomm": road_feature['rcomm']
        }
        enabled_road_cells = []
        self.pop_result_values_table(self.dockwidget.tbl_AddAddress_RoadInfo, road_values, enabled_road_cells)

        self.iface.mapCanvas().setMapTool(self.prev_tool)
    
    def pop_result_values_table(self, table, values, enabled_cells):
        row_count = table.rowCount()
        for row in range(row_count):
            row_name = table.verticalHeaderItem(row).text()
            item = QTableWidgetItem(str(row * 0))
            if row_name in enabled_cells:
                flags = (Qt.ItemIsEditable | Qt.ItemIsEnabled)
            else:
                flags = Qt.ItemIsEnabled
            item.setFlags(flags)
            item.setText(f"{values[row_name]}")
            table.setItem(row, 0, item)

    """def get_nearest_road(self):
        # Get the current tool
        self.prev_tool = self.canvas.mapTool()"""
    
    def cancel_canvas_capture(self):
        self.iface.mapCanvas().setMapTool(self.prev_tool)

    def get_nearest_road_feature(self, point):
        # From https://gis.stackexchange.com/questions/59173/finding-nearest-line-to-point-in-qgis
        # roads_layer = self.dockwidget.mLyrCbo_Roads.currentLayer()
        roads_layer = self.get_layer('roads')
        # provider = roads_layer.dataProvider()
        # features = provider.getFeatures()  # gets all features in layer
        features = roads_layer.getFeatures()

        spatial_index = QgsSpatialIndex()  # create spatial index object

        # insert features to index
        for feature in features:
            spatial_index.insertFeature(feature)

        # QgsSpatialIndex.nearestNeighbor (QgsPoint point, int neighbors)
        fids = spatial_index.nearestNeighbor(point, 5)  # Comparing nearest 5. Using only 1 was not always accurate.
        dist = 999999
        fid_hold = 0
        context_hold = None
        for fid in fids:
            road_features = roads_layer.getFeatures(f"$id = {fid}")
            road_feature = None
            # No, feats[0] does not work.
            for road_feature in road_features:
                context = self.get_nearest_road_segment_context(road_feature, point)
                min_dist = context['min_dist']
                if min_dist < dist:
                    dist = min_dist
                    fid_hold = fid
                    context_hold = context

        road_features = roads_layer.getFeatures(f"$id = {fid_hold}")
        road_feature = None
        # No, feats[0] does not work.
        for road_feature in road_features:
            break
        return {'road_feature': road_feature, 'context': context_hold}

    def get_nearest_road_segment_context(self, road_feature, point):
        # From https://qgis.org/api/classQgsGeometry.html#af949da066f8d1649a043cd320af1e7f7
        segment_context = road_feature.geometry().closestSegmentWithContext(point)
        # print(segment_context)  # prints the list of values and objects

        # The output is the distance squared. num ** (1/2) finds the square root.
        min_dist = segment_context[0] ** (1/2)

        # Is a geometry object; should be able to work out the m_distance with this.
        nearest_point_on_line_obj = segment_context[1]

        # It can figure out the closest point to the line without needing it exactly on the line.
        # point_geom = QgsGeometry.fromPointXY(point)
        # m_dist = road_feature.geometry().lineLocatePoint(point_geom)

        # But since we've already got it calculated, why waste processing time on it again?
        m_dist = road_feature.geometry().lineLocatePoint(QgsGeometry.fromPointXY(segment_context[1]))


        # Technically, it's the next vertex index, but easier to think of it this way.
        nearest_segment_of_line = segment_context[2]

        # -1 = Left, 0 = On the line, 1 = Right
        if segment_context[3] == -1:
            side_of_line = 'l'
        elif segment_context[3] == 1:
            side_of_line = 'r'

        """
        print(f"min_dist: {min_dist}")
        print(f"nearest_point_on_line_obj: {nearest_point_on_line_obj}")
        print(f"m_dist: {m_dist}")
        print(f"nearest_segment_of_line: {nearest_segment_of_line}")
        print(f"side_of_line: {side_of_line}")
        """

        # Then x = get_nearest_road_segment_context('variable_name')
        return {'min_dist': min_dist, 'nearest_point_on_line_obj': nearest_point_on_line_obj, 'm_dist': m_dist,
                'nearest_segment_of_line': nearest_segment_of_line, 'side_of_line': side_of_line}


    def convert_xy(self):
        # Convert a given PointXY object and get location assignments for DD and map projection units

        return lat, long, x, y
