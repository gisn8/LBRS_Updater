# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LBRS_Updater
                                 A QGIS plugin
 Update address and road LBRS features
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-10-14
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Nathan Saylor
        email                : gisn8@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import math

from PyQt5.QtWidgets import QTableWidgetItem
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
# Initialize Qt resources from file resources.py
from qgis._core import QgsProject, QgsSpatialIndex, QgsFeature, QgsFeatureRequest, QgsGeometry, QgsPoint, QgsPointXY, \
    QgsGeometryUtils, QgsCoordinateReferenceSystem, QgsCoordinateTransform
from qgis.gui import QgsMapToolEmitPoint
from qgis.core import QgsMapLayerProxyModel


from .resources import *

# Import the code for the DockWidget
from .lbrs_updater_dockwidget import LBRS_UpdaterDockWidget
import os.path
import time


class LBRS_Updater:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.canvas = self.iface.mapCanvas()

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'LBRS_Updater_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&LBRS Updater')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'LBRS_Updater')
        self.toolbar.setObjectName(u'LBRS_Updater')

        #print "** INITIALIZING LBRS_Updater"

        self.pluginIsActive = False
        self.dockwidget = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('LBRS_Updater', message)

    def add_action(self, icon_path, text, callback, enabled_flag=True, add_to_menu=True, add_to_toolbar=True,
                   status_tip=None, whats_this=None, parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/lbrs_updater/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'LBRS Updater'),
            callback=self.run,
            parent=self.iface.mainWindow())

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING LBRS_Updater"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD LBRS_Updater"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&LBRS Updater'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    # --------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING LBRS_Updater"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = LBRS_UpdaterDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.initialize()
            self.dockwidget.show()



    # Tools
    def get_layer(self, layer_name):
        try:
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            return layer
        except:
            try:
                layer = QgsProject.instance().mapGroupLayersByName(layer_name)[0]
                return layer
            except:
                pass

    def check_for_fields(self, layer, fields):
        # modified from https://gis.stackexchange.com/questions/299263/
        i = 1
        for field in fields:
            field_index = layer.fields().indexFromName(field)
            if field_index == -1:
                i = i * 0
            else:
                i = i * 1
        j = 1
        for field in fields:
            field_index = layer.fields().indexFromName(field.upper())
            if field_index == -1:
                j = j * 0
            else:
                j = j * 1
        if (i == 1) or (j == 1):
            return 1

    def get_feature_values_list(self, layer, field_name, filter_=None, distinct=1):
        # Used to populate values in combo boxes
        if filter_ is None:
            filter_ = f'{field_name} is not NULL'
        else:
            pass

        features = layer.getFeatures(filter_)
        list_ = []
        for feature in features:
            list_.append(feature[field_name])

        if distinct == 1:
            distinct_list = self.make_list_distinct(list_)
            return distinct_list
        else:
            return list_

    def make_list_distinct(self, list_):
        distinct_list = []
        for item in list(set(list_)):
            distinct_list.append(item)
        distinct_list.sort()
        return distinct_list

    def pop_tbl(self, layer, table, filter_=None, show_fields_list=[]):
        # layer = self.get_layer(layer_name)
        self.reset_result_displays()

        if filter_ is None:
            filter_ = '1=1'
        features = layer.getFeatures(filter_)

        table.setColumnCount(layer.fields().count())

        row = 0
        for feature in features:
            table.insertRow(row)
            for col in range(layer.fields().count()):
                table.setItem(row, col, QTableWidgetItem(str(feature[col])))
                # print(r"row: %s, col: %s, %s" % (row, col, feature[col]))
            row += 1

        # Probably will be argued in later as the rest of this already is.
        self.dockwidget.lbl_SearchAddress_Results.setText(f'Results: {row}')
        # That or just sneak it in because no one is looking anyway and it's demand is negligible

        if row == 0:
            self.reset_result_displays()
        else:
            field_names = []
            for field in layer.fields():
                # print(field.name())
                # field_names.append(u'%s' % field.name())
                field_names.append(f"{field.name()}")
            table.setHorizontalHeaderLabels(field_names)

            if len(show_fields_list) > 0:
                for field_name in field_names:
                    if field_name not in show_fields_list:
                        table.setColumnHidden(layer.fields().indexFromName(field_name), True)

        table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)

    def get_selected_row_cell(self, table, field_name):
        row = table.currentItem().row()
        if row is None:
            pass
        else:
            row = table.currentItem().row()
            # print(row)
            # col = table.currentItem().column()

            # loop through headers and find column number for given column name
            header_count = table.columnCount()
            for x in range(0, header_count, 1):
                header_name = table.horizontalHeaderItem(x).text()
                if field_name == header_name:
                    cell = table.item(row, x).text()  # get cell at row, col
                    # print(cell)ll
                    return cell

    def zoom_to_feature(self, layer):
        # Get selected item from result table, query for duplicates. If duplicates found, pop up box with cboBox to
        # select from to continue, then zoom to features.

        query = f"gid = {self.get_selected_row_cell(self.dockwidget.tbl_SearchAddress_Results, 'gid')}"
        # print(query)
        canvas = self.iface.mapCanvas()

        # Hold any selected features to give back after the function
        held_ids = [f.id() for f in layer.selectedFeatures()]
        layer.removeSelection()

        features = layer.getFeatures(query)
        ids = [i.id() for i in features]
        # print(len(ids))
        layer.selectByIds(ids)
        canvas.zoomToSelected(layer)

        # clear zooming selection and re-select original selected features
        layer.removeSelection()
        layer.selectByIds(held_ids)

        # Will also shake the canvas into not showing the zoomed feature as selected if it wasn't to begin with.
        # if scale != None:
        canvas.zoomScale(600)

    def get_xy_from_canvas(self, point, button):
        # Report map coordinates from a canvas click
        # self.canvas_x = point.x()
        # self.canvas_y = point.y()
        self.canvas_point = point
        # print(f"{x}, {y}")

    def solve_angle(self, from_point, to_point):
        # From https://qgis.org/pyqgis/3.2/core/Geometry/QgsGeometryUtils.html#qgis.core.QgsGeometryUtils.lineAngle
        # .lineAngle results in radians and need converted with math.degrees.
        # Angles are calculated clockwise from North.
        # By default, labels are perpendicular to the angle, so correct with a-90 for our purposes.
        # Note: Pad labels with 3 spaces on either side to get proper distance from point.
        # We'll want to integrate this into a newly formatted address layer when we're ready.
        a = QgsGeometryUtils.lineAngle(from_point.x(), from_point.y(),  to_point.x(), to_point.y())

        angle = round(math.degrees(a), 3)

        return angle

    def convert_xy(self, layer=None, point=None, x=None, y=None, crs=None):
        # Convert a given PointXY object and get location assignments for DD and map projection units
        # Derived from https://youtu.be/3YXjYAdAyjo

        print(f"layer: {layer}, point:{point}, x:{x}, y:{y}, crs:{crs}")

        if layer is None:
            layer = self.dockwidget.mLyrCbo_Addresses.currentLayer()

        # From given, extract: point, point_crs, x, y
        if point is not None:
            print('point is not none')
            x, y = point.x(), point.y()
        elif (x is not None) and (y is not None):
            print('xy is not none')
            point = QgsPointXY(x, y)
        elif (point is None) or ((x is None) or (y is None)):
            print('falling back to default')
            point = self.canvas_point
            x, y = point.x(), point.y()

        if crs is None:
            given_crs = QgsProject.instance().crs()
        else:
            given_crs = QgsCoordinateReferenceSystem(crs)

        # Layer crs
        layer_crs = layer.crs()
        layer_transformation = QgsCoordinateTransform(given_crs, layer_crs, QgsProject.instance())
        layer_point = layer_transformation.transform(QgsPointXY(x, y))
        layer_x = layer_point.x()
        layer_y = layer_point.y()

        # DD crs
        dd_crs = QgsCoordinateReferenceSystem(4326)
        dd_transformation = QgsCoordinateTransform(given_crs, dd_crs, QgsProject.instance())
        dd_point = dd_transformation.transform(QgsPointXY(x, y))
        lat = dd_point.y()
        long = dd_point.x()

        outputs = {
            "given_point": point, "given_x": x, "given_y": y,
            "layer_point": layer_point, "layer_x": layer_x, "layer_y": layer_y,
            "dd_point": dd_point, "lat": lat, "long": long}

        print(outputs)
        return outputs

    def get_crs_val_from_layer(self, layer):
        crs_val = int(layer.crs().authid().replace('EPSG:', ''))
        return crs_val

    def convert_xy_2(self, point=None, x=None, y=None, from_crs_val=None, to_crs_val=None):
        # Convert a given PointXY object and get location assignments for DD and map projection units
        # Derived from https://youtu.be/3YXjYAdAyjo

        print(f"INTAKE: point:{point}, x:{x}, y:{y}, from_crs_val:{from_crs_val} to_crs_val:{to_crs_val}")

        # Prepare needed variables with given variables
        if point is not None:
            print('point is not none')
            x, y = point.x(), point.y()
        elif (x is not None) and (y is not None):
            print('xy is not none')
            point = QgsPointXY(x, y)
        elif (point is None) or ((x is None) or (y is None)):
            print('falling back to default')
            point = self.canvas_point
            x, y = point.x(), point.y()

        if from_crs_val is None:
            # Default is canvas crs
            from_crs = QgsProject.instance().crs()
            from_crs_val = int(from_crs.authid().replace('EPSG:', ''))
        else:
            from_crs = QgsCoordinateReferenceSystem(from_crs_val)

        if to_crs_val is None:
            # default is address layer crs
            layer = self.dockwidget.mLyrCbo_Addresses.currentLayer() or self.get_layer('addresses')
            to_crs = layer.crs()
            to_crs_val = int(to_crs.authid().replace('EPSG:', ''))
        else:
            to_crs = QgsCoordinateReferenceSystem(to_crs_val)

        # Convert to to_crs
        to_crs_transformation = QgsCoordinateTransform(from_crs, to_crs, QgsProject.instance())
        new_point = to_crs_transformation.transform(QgsPointXY(x, y))
        new_x = new_point.x()
        new_y = new_point.y()

        # Convert to DD crs
        dd_crs = QgsCoordinateReferenceSystem(4326)
        dd_transformation = QgsCoordinateTransform(from_crs, dd_crs, QgsProject.instance())
        dd_point = dd_transformation.transform(QgsPointXY(x, y))
        lat = dd_point.y()
        long = dd_point.x()

        outputs = {
            "given_point": point, "given_x": x, "given_y": y, "given_crs_val": from_crs_val,
            "new_point": new_point, "new_x": new_x, "new_y": new_y, "new_crs_val": to_crs_val,
            "dd_point": dd_point, "lat": lat, "long": long
        }

        print(f"OUTPUTS: {outputs}")
        return outputs



    # Dockwidget
    def initialize(self):
        self.set_connections()
        self.reset_layer_cbos()
        self.reset_form()
        self.limit_layer_cbo_types()

        # For dev
        self.dockwidget.stackedWidget.setCurrentIndex(2)

    def set_connections(self):
        # All
        self.dockwidget.btnReset.clicked.connect(lambda: self.reset_form())

        # Page 0 - Menu
        self.set_menu_connections()

        # Page 1 - Search for Address
        self.set_search_address_connections()

        # Page 2 - Add Address
        self.set_add_address_connections()

    def reset_form(self):
        # -- Variables --
        self.canvas_point = None

        # -- Dockwidget --

        # Set default and hide error warning
        self.dockwidget.lblError.setText('')

        # Return to Menu
        self.dockwidget.stackedWidget.setCurrentIndex(0)

        # -- Menu --
        self.reset_menu_form()

        # -- Address Search --
        self.reset_address_search_form()

        # -- Add Address --
        self.reset_add_address_form()



    # Menu page
    def set_menu_connections(self):
        self.dockwidget.mLyrCbo_Addresses.currentTextChanged.connect(lambda: self.activate_menu_tools())
        self.dockwidget.mLyrCbo_Roads.currentTextChanged.connect(lambda: self.activate_menu_tools())
        self.dockwidget.btn_Menu_Continue.clicked.connect(lambda: self.continue_from_menu())

    def reset_layer_cbos(self):
        # Commenting out for development. Reinstate when ready.
        self.dockwidget.mLyrCbo_Addresses.setCurrentIndex(-1)
        self.dockwidget.mLyrCbo_Roads.setCurrentIndex(-1)
        self.dockwidget.grpTools.setEnabled(False)

    def limit_layer_cbo_types(self):
        # From https://github.com/qgis/QGIS/issues/38472
        # The map layer combo boxes don't translate layer type filters even after resetting them manually.
        # This is the workaround. Requires: from qgis.core import QgsMapLayerProxyModel
        self.dockwidget.mLyrCbo_Addresses.setFilters(QgsMapLayerProxyModel.PointLayer)
        self.dockwidget.mLyrCbo_Roads.setFilters(QgsMapLayerProxyModel.LineLayer)

    def reset_menu_form(self):
        self.dockwidget.cbo_Menu_Tool.setCurrentIndex(0)
        self.dockwidget.cbo_Menu_FeatureType.setCurrentIndex(0)

    def activate_menu_tools(self):
        if ((self.dockwidget.mLyrCbo_Addresses.currentIndex() != -1) and (self.dockwidget.mLyrCbo_Roads.currentIndex() != -1)):
            a = self.check_for_fields(self.dockwidget.mLyrCbo_Addresses.currentLayer(), ['featureid', 'housenum',
                                                                                        'unitnum', 'comment', 'side',
                                                                                        'absside', 'struc_type',
                                                                                        'source', 'comment', 'x', 'y'])
            if a == 1:
                r = self.check_for_fields(self.dockwidget.mLyrCbo_Roads.currentLayer(), ['segid', 'roadtype', 'roadnumber',
                                                                                         'st_prefix', 'st_name', 'st_type', 'st_suffix',
                                                                                         'altprefix', 'altname', 'alttype', 'altsuffix',
                                                                                         'fieldnote', 'leftfrom', 'rightto'])
                if r == 1:
                    self.dockwidget.lblError.setVisible(False)
                    self.dockwidget.lblError.setText('Loading data...')
                    self.dockwidget.lblError.setVisible(True)
                    self.dockwidget.repaint()
                    self.load_initial_data()
                    self.dockwidget.lblError.setText('')
                    self.dockwidget.grpTools.setEnabled(True)
                else:
                    self.dockwidget.grpTools.setEnabled(False)
                    self.dockwidget.lblError.setText('Road layer invalid')
            else:
                self.dockwidget.grpTools.setEnabled(False)
                self.dockwidget.lblError.setText('Address layer invalid')

    def load_initial_data(self):
        address_layer = self.dockwidget.mLyrCbo_Addresses.currentLayer()
        roads_layer = self.dockwidget.mLyrCbo_Roads.currentLayer()

        # Search for Address
        self.dockwidget.cbo_SearchAddress_st_name.addItem('')
        self.dockwidget.cbo_SearchAddress_comm.addItem('')

        self.dockwidget.cbo_SearchAddress_st_prefix.addItems(
            self.get_feature_values_list(address_layer, field_name='st_prefix'))
        self.dockwidget.cbo_SearchAddress_st_name.addItems(
            self.get_feature_values_list(address_layer, field_name='st_name'))
        self.dockwidget.cbo_SearchAddress_st_type.addItems(
            self.get_feature_values_list(address_layer, field_name='st_type'))
        self.dockwidget.cbo_SearchAddress_st_suffix.addItems(
            self.get_feature_values_list(address_layer, field_name='st_suffix'))
        self.dockwidget.cbo_SearchAddress_comm.addItems(
            self.get_feature_values_list(address_layer, field_name='comm'))

        self.dockwidget.cbo_SearchAddress_lsn.addItem('')
        self.dockwidget.cbo_SearchAddress_lsn.addItems(
            self.get_feature_values_list(address_layer, field_name='lsn'))

        self.dockwidget.list_SearchAddress_roads_lsn.addItems(
            self.get_feature_values_list(roads_layer, field_name='lsn'))

        # Add Address
        if address_layer.crs() is not None:
            self.dockwidget.rad_AddAddressByPoint_LayerCRS.setText(f"Address Layer CRS [{address_layer.crs().authid()}]")
        else:
            self.dockwidget.rad_AddAddressByPoint_LayerCRS.setText("Address Later CRS")

    def continue_from_menu(self):
        if self.dockwidget.cbo_Menu_FeatureType.currentText() == 'Address':
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Search for':
                self.dockwidget.stackedWidget.setCurrentIndex(1)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Add':
                self.dockwidget.stackedWidget.setCurrentIndex(2)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Update':
                self.dockwidget.stackedWidget.setCurrentIndex(3)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Re-Align':
                self.dockwidget.stackedWidget.setCurrentIndex(4)
            if self.dockwidget.cbo_Menu_Tool.currentText() == 'Retire':
                self.dockwidget.stackedWidget.setCurrentIndex(5)

        else:
            # For quick access in dev
            self.dockwidget.stackedWidget.setCurrentIndex(2)



    # Search Address page
    def set_search_address_connections(self):
        # Tab change
        self.dockwidget.tabs_SearchAddress.currentChanged.connect(lambda: self.reset_result_displays())
        # Find
        self.dockwidget.btn_SearchAddress_Find.clicked.connect(lambda: self.execute_address_query())
        # Clear
        self.dockwidget.btn_SearchAddress_Clear.clicked.connect(lambda: self.reset_address_search_form())
        # Zoom
        self.dockwidget.btn_SearchAddress_Zoom.clicked.connect(
            lambda: self.zoom_to_feature(self.dockwidget.mLyrCbo_Addresses.currentLayer()))
        # Continue
        self.dockwidget.btn_SearchAddress_Continue.clicked.connect(lambda: self.continue_from_address_search())

    def reset_address_search_form(self):
        self.dockwidget.lblError.setText('')

        self.dockwidget.ln_SearchAddress_housenum.clear()
        self.dockwidget.ln_SearchAddress_unitnum.clear()
        self.dockwidget.cbo_SearchAddress_st_prefix.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_name.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_type.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_st_suffix.setCurrentIndex(0)
        self.dockwidget.cbo_SearchAddress_comm.setCurrentIndex(0)

        self.dockwidget.cbo_SearchAddress_lsn.setCurrentIndex(0)
        
        self.reset_result_displays()

        self.dockwidget.cbo_SearchAddress_Tool.setCurrentIndex(0)

    def reset_result_displays(self): 
        self.dockwidget.tbl_SearchAddress_Results.clear()
        self.dockwidget.tbl_SearchAddress_Results.setColumnCount(0)
        self.dockwidget.tbl_SearchAddress_Results.setRowCount(0)
        self.dockwidget.lbl_SearchAddress_Results.setText('Results: 0')
        self.dockwidget.lblError.setText('')

    def execute_address_query(self):
        # get active address tab, build search parameters based on the active tab, and populate results
        self.dockwidget.lblError.setText('')
        query = ''
        address_tab_index = self.dockwidget.tabs_SearchAddress.currentIndex()

        # Component Search
        if address_tab_index == 0:
            query = '1=1'

            if len(self.dockwidget.ln_SearchAddress_housenum.text()) > 0:
                query = f"{query} AND to_string(housenum) = '{self.dockwidget.ln_SearchAddress_housenum.text()}'"

            if len(self.dockwidget.ln_SearchAddress_unitnum.text()) > 0:
                query = f"{query} AND unitnum = '{self.dockwidget.ln_SearchAddress_unitnum.text()}'"

            if len(self.dockwidget.cbo_SearchAddress_st_prefix.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_prefix = '{self.dockwidget.cbo_SearchAddress_st_prefix.currentText()}' OR " \
                        f"altprefix = '{self.dockwidget.cbo_SearchAddress_st_prefix.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_name.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_name = '{self.dockwidget.cbo_SearchAddress_st_name.currentText()}' OR " \
                        f"altname = '{self.dockwidget.cbo_SearchAddress_st_name.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_type.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_type = '{self.dockwidget.cbo_SearchAddress_st_type.currentText()}' OR " \
                        f"alttype = '{self.dockwidget.cbo_SearchAddress_st_type.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_st_suffix.currentText()) > 0:
                query = f"{query} AND (" \
                        f"st_suffix = '{self.dockwidget.cbo_SearchAddress_st_suffix.currentText()}' OR " \
                        f"altsuffix = '{self.dockwidget.cbo_SearchAddress_st_suffix.currentText()}')"

            if len(self.dockwidget.cbo_SearchAddress_comm.currentText()) > 0:
                query = f"{query} AND comm = '{self.dockwidget.cbo_SearchAddress_comm.currentText()}'"

            if query == '1=1':
                query = ''

        # Free-form Search
        if address_tab_index == 1:
            query = f"%{self.dockwidget.cbo_SearchAddress_lsn.currentText()}%"
            if query == '%%':
                query = ''
            else:
                query = f"lsn LIKE '{query}' OR alsn LIKE '{query}'"

        # Street-Level Search
        if address_tab_index == 2:
            if self.dockwidget.list_SearchAddress_roads_lsn.currentItem() is not None:
                query = f"% {self.dockwidget.list_SearchAddress_roads_lsn.currentItem().text()}"
                if query == '% ':
                    query = ''
                else:
                    query = f"lsn LIKE '{query}' OR alsn LIKE '{query}'"

        self.dockwidget.tbl_SearchAddress_Results.hide()
        self.dockwidget.repaint()
        time.sleep(0.02)
        self.dockwidget.tbl_SearchAddress_Results.show()
        self.dockwidget.repaint()

        if query != '':
            # print(query)
            self.pop_tbl(self.dockwidget.mLyrCbo_Addresses.currentLayer(), self.dockwidget.tbl_SearchAddress_Results,
                                    filter_=f'{query}', show_fields_list=['comment', 'lsn', 'comm', 'datemodifi'])
        else:
            self.reset_result_displays()
            self.dockwidget.lblError.setText('Error: Please refine search')

    def continue_from_address_search(self):
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Add':
            self.dockwidget.stackedWidget.setCurrentIndex(2)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Update':
            self.dockwidget.stackedWidget.setCurrentIndex(3)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Re-Align':
            self.dockwidget.stackedWidget.setCurrentIndex(4)
        if self.dockwidget.cbo_SearchAddress_Tool.currentText() == 'Retire':
            self.dockwidget.stackedWidget.setCurrentIndex(5)



    # Add Address page
    #   Add By Point
    def Add_Address_checklist():

        #Add Address page
        # Add Address by Point checklist
        """
        -- Steps to add address by point. --
        [X] layer validation (done beforehand)
        [X] click the button
        [X] get the previous tool
        [X] switch to xy tool
        [X] Cancel xy tool?
        [X] override selected road tool
        [X] convert PointXY values to DD and layer.prj units
        [X] set coordinate labels
        [X] seek nearest road segment feature
        [X] activate address and road tables
        [X] use road data to fill in address data table
        [X] calculate housenum and absside
        [X] Add cboBox to table cell? For struc_type
        [ ] begin edit of address layer
        [ ] add feature to address layer
        [ ] Function and connect Clear button on AddAddress form
        [ ] Function and connect Commit button on AddAddress form
        [ ] Make flexible for upper, lower, and mixed case field names

        Considerations
        Do we want to utilize ROW and snap to? Would require pointing to another reference layer... No.
        Set in-town and out-of-town distances from road CL to snap address points to? No. Not unless we're overriding
        for apartment entrances.
        Assign address to specific building AND link to aud_outbuilding... Should attempt an automated method to link
        together probably 75% of them, then tediously going through the other 25%.
        """
        pass

    def set_add_address_connections(self):
        self.dockwidget.btn_AddAddressByPoint_PlacePointOnMap.clicked.connect(lambda: self.start_xy_tool('PlacePointOnMap'))
        self.dockwidget.btn_AddAddressbyPoint_OverrideSelectedRoad.clicked.connect(lambda: self.start_xy_tool('OverrideSelectedRoad'))
        self.dockwidget.btn_AddAddressByPoint_Cancel.clicked.connect(self.cancel_canvas_capture)
        self.dockwidget.btn_AddAddressByPoint_Clear.clicked.connect(self.reset_add_address_form)
        self.dockwidget.btn_AddAddressByPoint_EnterManually.clicked.connect(lambda: self.dockwidget.stackedWidget_2.setCurrentIndex(1))
        self.dockwidget.btn_AddAddressbyPoint_GoBack.clicked.connect(lambda: self.dockwidget.stackedWidget_2.setCurrentIndex(0))
        self.dockwidget.btn_AddAddressByPoint_AcceptManualInput.clicked.connect(self.manual_point_entry)

    def reset_add_address_form(self):
        # Clear tables
        row_count = self.dockwidget.tbl_AddAddress_AddressInfo.rowCount()
        for row in range(row_count):
            item = QTableWidgetItem(str(row * 0))
            item.setText('')
            self.dockwidget.tbl_AddAddress_RoadInfo.setItem(row, 0, item)

        # De-activate tables
        self.dockwidget.tbl_AddAddress_AddressInfo.setEnabled(False)
        self.dockwidget.tbl_AddAddress_RoadInfo.setEnabled(False)

        # Reset coord labels
        self.dockwidget.lbl_AddAddress_Lat.setText('')
        self.dockwidget.lbl_AddAddress_Long.setText('')
        self.dockwidget.lbl_AddAddress_X.setText('')
        self.dockwidget.lbl_AddAddress_Y.setText('')

        # De-activate buttons
        self.dockwidget.btn_AddAddressbyPoint_OverrideSelectedRoad.setEnabled(False)
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(False)
        self.dockwidget.btn_AddAddressByPoint_Clear.setEnabled(False)
        self.dockwidget.btn_AddAddressByPoint_Commit.setEnabled(False)

    def start_xy_tool(self, btn):
        # Pycharm doesn't like creating a self.variable outside __init__. Tough! It works just fine!
        # Doing this just in case we have a point already assigned and decided we didn't want to override it.
        if self.canvas_point == None:
            self.canvas_x = 0
            self.canvas_y = 0

        # Get the current tool
        self.prev_tool = self.canvas.mapTool()

        # Create the map tool using the canvas reference
        # A self. assignment was found necessary for the tool to work ¯\_(ツ)_/¯
        self.xy_tool = QgsMapToolEmitPoint(self.canvas)
        self.xy_tool.canvasClicked.connect(self.get_xy_from_canvas)  # The connect works just fine
        if btn == 'PlacePointOnMap':
            self.xy_tool.canvasClicked.connect(self.manage_address_attributes)
        if btn == 'OverrideSelectedRoad':
            self.xy_tool.canvasClicked.connect(self.solve_attributes)
        self.canvas.setMapTool(self.xy_tool)
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(True)

    def manual_point_entry(self):
        if self.dockwidget.rad_AddAddressByPoint_DD.isChecked():
            layer = self.dockwidget.mLyrCbo_Addresses.currentLayer() or self.get_layer('addresses')
            coords = self.convert_xy_2(
                y=self.dockwidget.dblsp_AddAddressByPoint_Lat.value(),
                x=self.dockwidget.dblsp_AddAddressByPoint_Long.value(),
                from_crs_val=4326,
                to_crs_val=self.get_crs_val_from_layer(layer)
            )
            # coords = self.convert_xy(
            #     layer=self.get_layer('roads'),
            #     y=self.dockwidget.dblsp_AddAddressByPoint_Lat.value(),
            #     x=self.dockwidget.dblsp_AddAddressByPoint_Long.value(),
            #     crs=4326)
            self.manage_address_attributes(coords=coords)
            self.dockwidget.stackedWidget_2.setCurrentIndex(0)
        elif self.dockwidget.rad_AddAddressByPoint_LayerCRS.isChecked():
            layer = self.dockwidget.mLyrCbo_Addresses.currentLayer() or self.get_layer('addresses')
            coords = self.convert_xy_2(
                y=self.dockwidget.dblsp_AddAddressByPoint_Y.value(),
                x=self.dockwidget.dblsp_AddAddressByPoint_X.value(),
                from_crs_val=self.get_crs_val_from_layer(layer),
                to_crs_val=self.get_crs_val_from_layer(layer)
            )
            # coords = self.convert_xy(
            #     layer=self.get_layer('addresses'),
            #     y=self.dockwidget.dblsp_AddAddressByPoint_Y.value(),
            #     x=self.dockwidget.dblsp_AddAddressByPoint_X.value(),
            #     crs=crs)
            self.manage_address_attributes(coords=coords)
            self.dockwidget.stackedWidget_2.setCurrentIndex(0)
        else:
            pass


    def manage_address_attributes(self, point, btn, coords=None):  # the point and btn coming from the xy_tool come along for the ride.
        # coords = self.convert_xy()
        if coords is None:
            print("Coords is None")
            # coords = self.convert_xy(layer=self.get_layer('addresses'))
            coords = self.convert_xy_2()

        print(f"COORDS: {coords}")
        layer_x = coords['new_x']
        layer_y = coords['new_y']
        lat = coords['lat']
        long = coords['long']
        point = coords['new_point']
        point_crs_val = coords['new_crs_val']

        print(point_crs_val)

        self.dockwidget.lbl_AddAddress_X.setText(f"{round(layer_x, 3)}")
        self.dockwidget.lbl_AddAddress_Y.setText(f"{round(layer_y, 3)}")
        self.dockwidget.lbl_AddAddress_Lat.setText(f"{round(lat,7)}")
        self.dockwidget.lbl_AddAddress_Long.setText(f"{round(long,7)}")

        self.dockwidget.btn_AddAddressbyPoint_OverrideSelectedRoad.setEnabled(True)
        self.dockwidget.btn_AddAddressByPoint_Clear.setEnabled(True)
        self.dockwidget.btn_AddAddressByPoint_Commit.setEnabled(True)

        self.solve_attributes(point, point_crs_val)

    def solve_attributes(self, clicked_point, btn, point=None, point_crs_val=None):
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(False)

        self.dockwidget.tbl_AddAddress_AddressInfo.setEnabled(True)
        self.dockwidget.tbl_AddAddress_RoadInfo.setEnabled(True)

        print("solve_attributes")
        if point is None:
            point = self.canvas_point
        if point_crs_val is None:
            point_crs = QgsProject.instance().crs()
            point_crs_val = int(point_crs.authid().replace('EPSG:', ''))
        print(point)
        road_feature_data = self.get_nearest_road_feature(point, point_crs_val)
        road_feature = road_feature_data['road_feature']
        context = road_feature_data['context']
        reprojected_point = road_feature_data['reprojected_point']
        m_dist = context['m_dist']
        side_t = context['side_of_line']
        length = road_feature.geometry().length()

        print(f"Point 1: {context['nearest_point_on_line']}, Point 2: {reprojected_point}")
        angle = self.solve_angle(context['nearest_point_on_line'], reprojected_point)
        label_angle = round(angle - 90, 3)
        print(f"angle: {angle}")
        print(f"label_angle: {label_angle}")

        if (angle > 45) and (angle <=135):
            absside = 'E'
        elif (angle > 135) and (angle <= 225):
            absside = 'S'
        elif (angle > 225) and (angle <=315):
            absside = 'W'
        else:
            absside = 'N'

        if side_t == 'l':
            side_text = 'left'
            side = 0
        else:
            side_text = 'right'
            side = 1



        l_lsn = self.build_lsn(st_prefix=road_feature['lprefix'] or '',
                               st_name=road_feature['lname'] or '',
                               st_type=road_feature['ltype'] or '',
                               st_suffix=road_feature['lsuffix'] or '')
        r_lsn = self.build_lsn(st_prefix=road_feature['rprefix'] or '',
                               st_name=road_feature['rname'] or '',
                               st_type=road_feature['rtype'] or '',
                               st_suffix=road_feature['rsuffix'] or '')

        road_values = {
            "segid": str(int(road_feature['segid'])),
            "roadtype": road_feature['roadtype'],
            "roadnumber": road_feature['roadnumber'],
            "leftfrom": road_feature['leftfrom'],
            "leftto": road_feature['leftto'],
            "l_lsn": l_lsn,
            "lcomm": road_feature['lcomm'],
            "rightfrom": road_feature['rightfrom'],
            "rightto": road_feature['rightto'],
            "r_lsn": r_lsn,
            "rcomm": road_feature['rcomm'],
            "length": length
        }
        enabled_road_cells = []
        self.pop_result_values_table(self.dockwidget.tbl_AddAddress_RoadInfo, road_values, enabled_road_cells)

        housenum = self.solve_housenum(from_=road_feature[f"{side_text}from"], to_=road_feature[f"{side_text}to"],
                                       m_dist=m_dist, length=length)

        st_lsn = self.build_lsn(st_prefix=road_feature[f"{side_t}prefix"] or road_feature['st_prefix'] or '',
                                st_name=road_feature[f"{side_t}name"] or road_feature['st_name'] or '',
                                st_type=road_feature[f"{side_t}type"] or road_feature['st_type'] or '',
                                st_suffix=road_feature[f"{side_t}suffix"] or road_feature['st_suffix'] or '')

        address_values = {
            "segid": str(int(road_feature['segid'])),
            "housenum": housenum,
            "unitnum": '',
            "struc_type": '',
            "poi_name": '',
            "st_lsn": st_lsn,
            "absside": absside,
            "muni": road_feature[f"{side_t}addmuni"] or '',
            "zipcode": road_feature[f"{side_text}zip"],
            "comm": road_feature[f"{side_t}comm"],
            "note": '',
            "side": side
        }
        enabled_address_cells = ['housenum', 'unitnum', 'struc_type', 'poi_name', 'note']
        self.pop_result_values_table(self.dockwidget.tbl_AddAddress_AddressInfo, address_values, enabled_address_cells)

        cbo_struc_type = QtWidgets.QComboBox()
        cbo_struc_type.addItems([
            "1 - House",
            "2 - Duplex",
            "3 - Trailer",
            "4 - Apartment (single unit)",
            "5 - Secondary (barn, garage, etc. with address)",
            "6 - Utility (gas, electric, cellular, etc.)",
            "7 - Commercial",
            "8 - Address with no visible structure",
            "9 - Apartment (one entrance w/suffix range)",
            "10 - Campground Lot",
            "11 - Landmark (cemetery, park, etc.)",
            "12 - Apartment (one entrance w/address range)",
            # 13 not used
            "14 - Points for Review"])
        cbo_struc_type.setCurrentIndex(-1)
        table = self.dockwidget.tbl_AddAddress_AddressInfo
        row_count = table.rowCount()
        for row in range(row_count):
            row_name = table.verticalHeaderItem(row).text()
            if row_name == 'struc_type':
                table.setCellWidget(row, 0, cbo_struc_type)

        try:
            self.iface.mapCanvas().setMapTool(self.prev_tool)
        except:
            pass

    def solve_housenum(self, from_=0, to_=0, m_dist=0, length=0):
        pct = m_dist / length

        if to_ - from_ >= 0:
            numsign = 1
        else:
            numsign = -1

        min_ = min(from_, to_)
        max_ = max(from_, to_)
        range_ = max_ - min_
        val_ = range_ * pct
        floor_ = math.floor(from_ + (val_ * numsign))
        ceil_ = math.ceil(from_ + (val_ * numsign))

        if (from_ % 2) != (to_ % 2):
            housenum = round(min_ + val_)
        elif (from_ % 2) == (floor_ % 2):
            housenum = floor_
        else:
            housenum = ceil_

        return housenum

    def build_lsn(self, housenum='', st_prefix='', st_name='', st_type='', st_suffix=''):
        lsn = ''
        if housenum != '':
            lsn = f"{housenum} "
        if st_prefix != '':
            lsn = f"{lsn}{st_prefix} "
        lsn = f"{lsn}{st_name}"
        if st_type != '':
            lsn = f"{lsn} {st_type}"
        if st_suffix != '':
            lsn = f"{lsn} {st_suffix}"

        return lsn

    def build_address_values(self, road_feature):
        address_values = {
            "segid": str(int(road_feature['segid'])),
            "housenum": housenum,
            "unitnum": '',
            "struc_type": '',
            "poi_name": '',
            "st_lsn": st_lsn,
            "absside": absside,
            "muni": road_feature[f"{side_t}addmuni"] or '',
            "zipcode": road_feature[f"{side_text}zip"],
            "comm": road_feature[f"{side_t}comm"],
            "note": '',
            "side": side
        }

    def pop_result_values_table(self, table, values, enabled_cells):
        row_count = table.rowCount()
        for row in range(row_count):
            row_name = table.verticalHeaderItem(row).text()
            item = QTableWidgetItem(str(row * 0))
            if row_name in enabled_cells:
                flags = (Qt.ItemIsEditable | Qt.ItemIsEnabled)
            else:
                flags = Qt.ItemIsEnabled
            item.setFlags(flags)
            item.setText(f"{values[row_name]}")
            table.setItem(row, 0, item)

    def get_nearest_road_feature(self, point, point_crs_val=None):
        # From https://gis.stackexchange.com/questions/59173/finding-nearest-line-to-point-in-qgis
        # roads_layer = self.dockwidget.mLyrCbo_Roads.currentLayer()
        roads_layer = self.dockwidget.mLyrCbo_Roads.currentLayer() or self.get_layer('roads')
        features = roads_layer.getFeatures()

        # point_conversion = self.convert_xy(layer=roads_layer, point=point)
        point_conversion = self.convert_xy_2(point, from_crs_val=point_crs_val, to_crs_val=self.get_crs_val_from_layer(roads_layer))
        point = point_conversion['new_point']

        spatial_index = QgsSpatialIndex()  # create spatial index object

        # insert features to index
        for feature in features:
            spatial_index.insertFeature(feature)

        # QgsSpatialIndex.nearestNeighbor (QgsPoint point, int neighbors)
        fids = spatial_index.nearestNeighbor(point, 5)  # Comparing nearest 5. Using only 1 was not always accurate.
        dist = 999999
        fid_hold = 0
        context_hold = None
        for fid in fids:
            road_features = roads_layer.getFeatures(f"$id = {fid}")
            for road_feature in road_features:
                context = self.get_nearest_road_segment_context(road_feature, point)
                min_dist = context['min_dist']
                if min_dist < dist:
                    dist = min_dist
                    fid_hold = fid
                    context_hold = context

        road_features = roads_layer.getFeatures(f"$id = {fid_hold}")
        road_feature = None  # Just to shut up PyCharm
        # No, feats[0] does not work.
        for road_feature in road_features:
            break
        return {'road_feature': road_feature, 'context': context_hold, 'reprojected_point': point}

    def get_nearest_road_segment_context(self, road_feature, point):
        # From https://qgis.org/api/classQgsGeometry.html#af949da066f8d1649a043cd320af1e7f7
        segment_context = road_feature.geometry().closestSegmentWithContext(point)
        # print(segment_context)  # prints the list of values and objects

        # The output is the distance squared. num ** (1/2) finds the square root.
        min_dist = segment_context[0] ** (1/2)

        # Is a geometry object; should be able to work out the m_distance with this.
        nearest_point_on_line = segment_context[1]

        # It can figure out the closest point to the line without needing it exactly on the line.
        # point_geom = QgsGeometry.fromPointXY(point)
        # m_dist = road_feature.geometry().lineLocatePoint(point_geom)

        # But since we've already got it calculated, why waste processing time on it again?
        m_dist = road_feature.geometry().lineLocatePoint(QgsGeometry.fromPointXY(segment_context[1]))


        # Technically, it's the next vertex index, but easier to think of it this way.
        nearest_segment_of_line = segment_context[2]

        # -1 = Left, 0 = On the line, 1 = Right;
        # figure this will keep anything from breaking down if it's accidentally on the line.
        if segment_context[3] <= 0:
            side_of_line = 'l'
        elif segment_context[3] == 1:
            side_of_line = 'r'

        """
        print(f"min_dist: {min_dist}")
        print(f"nearest_point_on_line: {nearest_point_on_line}")
        print(f"m_dist: {m_dist}")
        print(f"nearest_segment_of_line: {nearest_segment_of_line}")
        print(f"side_of_line: {side_of_line}")
        """

        # Then x = get_nearest_road_segment_context('variable_name')
        return {'min_dist': min_dist, 'nearest_point_on_line': nearest_point_on_line, 'm_dist': m_dist,
                'nearest_segment_of_line': nearest_segment_of_line, 'side_of_line': side_of_line}

    def cancel_canvas_capture(self):
        self.iface.mapCanvas().setMapTool(self.prev_tool)
        self.dockwidget.btn_AddAddressByPoint_Cancel.setEnabled(False)

    #   Add By Distance
    #   Add By Coordinate Entry
    #   Add By Calculation

